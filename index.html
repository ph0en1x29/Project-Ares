<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Project Ares â€” Live</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700;800&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CSS â€” DARK THEME
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
  --bg-0: #06080C;
  --bg-1: #0C0E14;
  --bg-2: #11141B;
  --bg-3: #181C26;
  --border: #1C2030;
  --border-h: #252A3A;
  --text-0: #E8ECF4;
  --text-1: #A0A8BA;
  --text-2: #5A6278;
  --text-3: #3A4058;
  --blue: #3B82F6;
  --purple: #8B5CF6;
  --amber: #F59E0B;
  --red: #EF4444;
  --green: #10B981;
  --green-bright: #00E676;
  --red-bright: #FF5252;
  --orange: #FF9800;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg-0); color: var(--text-0);
  font-family: 'DM Sans', system-ui, sans-serif;
  min-height: 100vh; padding: 16px 20px;
  -webkit-font-smoothing: antialiased;
}
.mono { font-family: 'JetBrains Mono', monospace; }

@keyframes pulse { 0%,100% { opacity:1 } 50% { opacity:0.3 } }
@keyframes slideIn { from { opacity:0; transform:translateY(8px) } to { opacity:1; transform:none } }
@keyframes spin { from { transform:rotate(0deg) } to { transform:rotate(360deg) } }

.slide-in { animation: slideIn 0.3s ease both; }
.spinner { animation: spin 1s linear infinite; display: inline-block; }

.live-num { transition: color 0.4s ease; display: inline-block; }
.live-num.tick-up { color: var(--green-bright) !important; }
.live-num.tick-dn { color: var(--red-bright) !important; }

.dot { width:7px; height:7px; border-radius:50%; flex-shrink:0; display:inline-block; }
.dot.live { background:var(--green-bright); animation:pulse 2s infinite; }
.dot.ws { background:var(--blue); animation:pulse 1.5s infinite; }
.dot.off { background:var(--red-bright); }

/* â”€â”€ HEADER â”€â”€ */
.header { display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:14px; flex-wrap:wrap; gap:12px; }
.header-left h1 { font-size:22px; font-weight:800; line-height:1; letter-spacing:-0.5px; }
.status-row { display:flex; align-items:center; gap:8px; margin-top:5px; font-size:10px; color:var(--text-2); flex-wrap:wrap; }

/* â”€â”€ TABS â”€â”€ */
.tabs { display:flex; gap:4px; margin-bottom:14px; background:var(--bg-2); padding:4px; border-radius:10px; border:1px solid var(--border); }
.tab { flex:1; text-align:center; padding:10px 16px; border-radius:8px; cursor:pointer; font-weight:600; font-size:13px; color:var(--text-2); transition:all 0.2s; }
.tab:hover { color:var(--text-1); }
.tab.active { background:var(--bg-3); color:var(--text-0); box-shadow:0 2px 8px rgba(0,0,0,0.3); }
.tab-content { display:none; }
.tab-content.active { display:block; }

/* â”€â”€ SEARCH â”€â”€ */
.search-container { position:relative; margin-bottom:14px; }
.search-input { width:100%; background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:12px 16px 12px 44px; color:var(--text-0); font-size:14px; outline:none; }
.search-input:focus { border-color:var(--blue); }
.search-input::placeholder { color:var(--text-3); }
.search-icon { position:absolute; left:16px; top:50%; transform:translateY(-50%); color:var(--text-3); font-size:16px; }
.search-results { position:absolute; top:100%; left:0; right:0; background:var(--bg-2); border:1px solid var(--border); border-radius:10px; margin-top:4px; max-height:300px; overflow-y:auto; z-index:100; display:none; }
.search-results.show { display:block; }
.search-result { padding:12px 16px; cursor:pointer; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; }
.search-result:last-child { border-bottom:none; }
.search-result:hover { background:var(--bg-3); }
.search-result .sym { font-weight:700; color:var(--text-0); }
.search-result .desc { font-size:12px; color:var(--text-2); }

/* â”€â”€ MARKET ROW â”€â”€ */
.market-row { display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; }
.market-chip { background:var(--bg-2); border:1px solid var(--border); border-radius:8px; padding:8px 14px; flex:1; min-width:100px; }
.market-chip .lbl { font-size:8px; color:var(--text-3); letter-spacing:1.5px; }
.market-chip .val { font-size:17px; font-weight:700; margin-top:1px; }
.market-chip .chg { font-size:10px; margin-top:1px; }

/* â”€â”€ PHASE BANNER â”€â”€ */
.phase-banner { border-radius:10px; padding:12px 18px; margin-bottom:12px; display:flex; justify-content:space-between; align-items:center; border:1px solid; flex-wrap:wrap; gap:8px; }

/* â”€â”€ API SETUP â”€â”€ */
.api-setup { background:var(--bg-2); border:1px solid var(--blue)40; border-radius:10px; padding:16px 20px; margin-bottom:14px; display:none; }
.api-setup.show { display:block; }
.api-setup h3 { font-size:13px; color:var(--blue); margin-bottom:8px; }
.api-setup p { font-size:11px; color:var(--text-1); line-height:1.6; margin-bottom:10px; }
.api-setup .steps { font-size:11px; color:var(--text-2); line-height:1.8; }
.api-setup .steps strong { color:var(--text-1); }
.api-input-row { display:flex; gap:8px; margin-top:10px; }
.api-input-row input { flex:1; background:var(--bg-1); border:1px solid var(--border); border-radius:6px; padding:8px 12px; color:var(--text-0); font-family:'JetBrains Mono',monospace; font-size:12px; outline:none; }
.api-input-row input:focus { border-color:var(--blue); }
.api-input-row input::placeholder { color:var(--text-3); }

/* â”€â”€ BUTTONS â”€â”€ */
.btn { background:var(--blue); color:white; border:none; border-radius:6px; padding:8px 16px; font-weight:600; cursor:pointer; font-size:12px; transition:opacity 0.2s; }
.btn:hover { opacity:0.85; }
.btn:disabled { opacity:0.5; cursor:not-allowed; }
.btn-sm { padding:4px 10px; font-size:10px; border-radius:4px; }
.btn-outline { background:transparent; border:1px solid var(--border); color:var(--text-1); }
.btn-outline:hover { border-color:var(--text-2); }
.btn-green { background:var(--green); }
.btn-red { background:var(--red); }
.btn-amber { background:var(--amber); color:#000; }

/* â”€â”€ WEIGHTS â”€â”€ */
.weights-panel { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:10px 14px; margin-bottom:12px; }
.weights-grid { display:grid; grid-template-columns:repeat(5,1fr); gap:14px; }
@media(max-width:600px) { .weights-grid { grid-template-columns:repeat(2,1fr); } }
.weight-item label { display:flex; justify-content:space-between; font-size:9px; margin-bottom:3px; }
input[type="range"] { -webkit-appearance:none; width:100%; height:3px; background:var(--bg-3); border-radius:2px; outline:none; cursor:pointer; }
input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; width:12px; height:12px; background:var(--blue); border-radius:50%; cursor:pointer; border:2px solid var(--bg-0); }

/* â”€â”€ CARDS GRID â”€â”€ */
.cards-grid { display:grid; grid-template-columns:repeat(5,1fr); gap:10px; margin-bottom:14px; }
@media(max-width:1100px) { .cards-grid { grid-template-columns:repeat(3,1fr); } }
@media(max-width:700px) { .cards-grid { grid-template-columns:repeat(2,1fr); } }
@media(max-width:450px) { .cards-grid { grid-template-columns:1fr; } }

.ticker-card { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:14px; cursor:pointer; transition: border-color 0.2s, transform 0.2s; position:relative; overflow:hidden; }
.ticker-card:hover { border-color:var(--border-h); transform:translateY(-1px); }
.ticker-card.selected { background:var(--bg-3); }
.ticker-card .accent { position:absolute; top:0; left:0; right:0; height:2px; }
.ticker-card .top { display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:6px; }
.ticker-card .sym { font-size:15px; font-weight:700; letter-spacing:0.5px; }
.ticker-card .nm { font-size:9px; color:var(--text-3); }
.ticker-card .remove-btn { position:absolute; top:8px; right:8px; background:var(--bg-3); border:none; color:var(--text-3); width:18px; height:18px; border-radius:4px; cursor:pointer; font-size:12px; line-height:1; opacity:0; transition:opacity 0.2s; }
.ticker-card:hover .remove-btn { opacity:1; }
.ticker-card .remove-btn:hover { background:var(--red); color:white; }
.signal-badge { padding:2px 7px; border-radius:4px; font-size:8px; font-weight:700; letter-spacing:0.5px; transition: background 0.4s, color 0.4s; }
.ticker-card .price-row { display:flex; justify-content:space-between; align-items:baseline; margin-bottom:8px; }
.ticker-card .price { font-size:20px; font-weight:700; }
.ticker-card .day-chg { font-size:11px; font-weight:600; }
.ticker-card .meta-row { display:flex; gap:6px; font-size:8px; color:var(--text-3); margin-bottom:8px; flex-wrap:wrap; }
.ticker-card .actions { margin-top:8px; padding-top:8px; border-top:1px solid var(--border); display:flex; gap:6px; }
.ticker-card .actions .btn { flex:1; font-size:9px; padding:5px 8px; }

.score-bar { margin-bottom:3px; }
.score-bar .bar-hdr { display:flex; justify-content:space-between; font-size:8px; color:var(--text-2); margin-bottom:1px; }
.score-bar .bar-hdr .bv { color:var(--text-1); font-weight:600; }
.bar-track { background:var(--bg-3); border-radius:3px; height:4px; overflow:hidden; }
.bar-fill { height:100%; border-radius:3px; transition: width 0.8s cubic-bezier(.4,0,.2,1); }

.composite-row { margin-top:8px; padding-top:8px; border-top:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; }
.composite-row .cl { font-size:8px; color:var(--text-3); }
.composite-row .cv { font-size:20px; font-weight:800; transition: color 0.4s; }

/* â”€â”€ DETAIL PANEL â”€â”€ */
.detail-panel { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:18px; margin-bottom:14px; }
.detail-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; flex-wrap:wrap; gap:8px; }
.detail-title { display:flex; align-items:center; gap:10px; }
.detail-title .bar { width:3px; height:26px; border-radius:2px; }
.detail-title h2 { font-size:16px; font-weight:700; }
.detail-title .sub { font-size:10px; color:var(--text-2); margin-top:1px; }
.detail-signal { padding:5px 12px; border-radius:6px; font-size:12px; font-weight:700; transition: background 0.4s, color 0.4s; }

.metrics-grid { display:grid; grid-template-columns:repeat(6,1fr); gap:5px; margin-bottom:14px; }
@media(max-width:900px) { .metrics-grid { grid-template-columns:repeat(3,1fr); } }
@media(max-width:500px) { .metrics-grid { grid-template-columns:repeat(2,1fr); } }
.metric-box { background:var(--bg-1); border-radius:6px; padding:6px 10px; border:1px solid #141824; }
.metric-box .ml { font-size:7px; color:var(--text-3); text-transform:uppercase; letter-spacing:0.8px; }
.metric-box .mv { font-size:11px; font-weight:600; margin-top:1px; color:var(--text-1); transition: color 0.3s; }
.metric-box .mv.warn { color:var(--amber); }

.detail-cols { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
@media(max-width:700px) { .detail-cols { grid-template-columns:1fr; } }
.section-title { font-size:9px; color:var(--text-3); letter-spacing:1px; margin-bottom:8px; }
.factors { font-size:11px; color:var(--text-2); line-height:1.8; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PAPER TRADING STYLES
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.portfolio-summary { display:grid; grid-template-columns:repeat(5,1fr); gap:10px; margin-bottom:16px; }
@media(max-width:900px) { .portfolio-summary { grid-template-columns:repeat(3,1fr); } }
@media(max-width:500px) { .portfolio-summary { grid-template-columns:repeat(2,1fr); } }
.portfolio-card { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:14px; }
.portfolio-card .label { font-size:9px; color:var(--text-3); letter-spacing:1px; margin-bottom:4px; }
.portfolio-card .value { font-size:22px; font-weight:800; }
.portfolio-card .sub { font-size:10px; color:var(--text-2); margin-top:2px; }

.positions-table, .trades-table { width:100%; border-collapse:collapse; margin-bottom:16px; }
.positions-table th, .trades-table th { text-align:left; font-size:9px; color:var(--text-3); letter-spacing:1px; padding:10px 12px; border-bottom:1px solid var(--border); }
.positions-table td, .trades-table td { padding:12px; border-bottom:1px solid var(--border); font-size:12px; }
.positions-table tr:hover, .trades-table tr:hover { background:var(--bg-3); }

/* â”€â”€ MODAL â”€â”€ */
.modal-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; z-index:1000; display:none; }
.modal-overlay.show { display:flex; }
.modal { background:var(--bg-2); border:1px solid var(--border); border-radius:12px; padding:24px; max-width:400px; width:90%; }
.modal h3 { font-size:16px; margin-bottom:16px; }
.modal-field { margin-bottom:14px; }
.modal-field label { display:block; font-size:10px; color:var(--text-2); margin-bottom:4px; }
.modal-field input { width:100%; background:var(--bg-1); border:1px solid var(--border); border-radius:6px; padding:10px 12px; color:var(--text-0); font-size:14px; outline:none; }
.modal-field input:focus { border-color:var(--blue); }
.modal-actions { display:flex; gap:10px; margin-top:20px; }
.modal-actions .btn { flex:1; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PERFORMANCE / CHART STYLES
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.chart-container { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:16px; margin-bottom:16px; }
.chart-container h3 { font-size:12px; color:var(--text-2); margin-bottom:12px; }
.chart-svg { width:100%; height:200px; }
.chart-line { fill:none; stroke:var(--blue); stroke-width:2; }
.chart-area { fill:url(#chartGradient); }
.chart-grid { stroke:var(--border); stroke-width:1; }
.chart-label { font-size:9px; fill:var(--text-3); }

.stats-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin-bottom:16px; }
@media(max-width:700px) { .stats-grid { grid-template-columns:repeat(2,1fr); } }
.stat-card { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:14px; }
.stat-card .label { font-size:9px; color:var(--text-3); letter-spacing:1px; margin-bottom:4px; }
.stat-card .value { font-size:18px; font-weight:700; }

.accuracy-section { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:16px; margin-bottom:16px; }
.accuracy-section h3 { font-size:12px; color:var(--text-2); margin-bottom:12px; }
.accuracy-bars { display:flex; flex-direction:column; gap:8px; }
.accuracy-bar { display:flex; align-items:center; gap:12px; }
.accuracy-bar .label { width:60px; font-size:11px; color:var(--text-2); }
.accuracy-bar .track { flex:1; height:20px; background:var(--bg-3); border-radius:4px; overflow:hidden; position:relative; }
.accuracy-bar .fill { height:100%; border-radius:4px; transition:width 0.8s; display:flex; align-items:center; justify-content:flex-end; padding-right:8px; font-size:10px; font-weight:600; }
.accuracy-bar .fill.good { background:var(--green); }
.accuracy-bar .fill.mid { background:var(--amber); }
.accuracy-bar .fill.bad { background:var(--red); }

/* â”€â”€ FOOTER â”€â”€ */
.footer { background:var(--bg-2); border:1px solid var(--border); border-radius:10px; padding:14px; font-size:10px; color:var(--text-3); line-height:1.8; }
.footer strong { color:var(--text-2); }
.footer .warn { color:#FF980055; font-size:9px; margin-top:6px; }

.up { color:var(--green-bright); }
.dn { color:var(--red-bright); }

.empty-state { text-align:center; padding:40px 20px; color:var(--text-2); }
.empty-state .icon { font-size:48px; margin-bottom:12px; opacity:0.5; }
.empty-state h4 { font-size:14px; margin-bottom:8px; color:var(--text-1); }
.empty-state p { font-size:12px; }

::-webkit-scrollbar { width:4px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:var(--bg-3); border-radius:2px; }
</style>
</head>
<body>
<div id="app"></div>

<!-- BUY MODAL -->
<div class="modal-overlay" id="buy-modal">
  <div class="modal">
    <h3 class="mono">ğŸ“ˆ Paper Buy â€” <span id="modal-ticker">â€”</span></h3>
    <div class="modal-field">
      <label class="mono">CURRENT PRICE</label>
      <input type="text" id="modal-price" readonly>
    </div>
    <div class="modal-field">
      <label class="mono">SHARES</label>
      <input type="number" id="modal-shares" placeholder="Enter number of shares" min="1" step="1">
    </div>
    <div class="modal-field">
      <label class="mono">STOP LOSS (OPTIONAL)</label>
      <input type="number" id="modal-stoploss" placeholder="e.g. 150.00" step="0.01">
    </div>
    <div class="modal-field">
      <label class="mono">TOTAL COST</label>
      <input type="text" id="modal-total" readonly>
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closeBuyModal()">Cancel</button>
      <button class="btn btn-green" onclick="executeBuy()">Buy</button>
    </div>
  </div>
</div>

<!-- CLOSE POSITION MODAL -->
<div class="modal-overlay" id="close-modal">
  <div class="modal">
    <h3 class="mono">ğŸ“‰ Close Position â€” <span id="close-modal-ticker">â€”</span></h3>
    <div class="modal-field">
      <label class="mono">SHARES OWNED</label>
      <input type="text" id="close-modal-shares" readonly>
    </div>
    <div class="modal-field">
      <label class="mono">CURRENT PRICE</label>
      <input type="text" id="close-modal-price" readonly>
    </div>
    <div class="modal-field">
      <label class="mono">P&L</label>
      <input type="text" id="close-modal-pnl" readonly>
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closeCloseModal()">Cancel</button>
      <button class="btn btn-red" onclick="executeClose()">Close Position</button>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PROJECT ARES v10.1 â€” FULL TRADING PLATFORM
//  Phase 1: Dynamic Search + Scoring
//  Phase 2: Supabase Integration
//  Phase 3: Paper Trading
//  Phase 4: Performance Analytics
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DEFAULT_TICKERS = ['NVDA','AMD','MU','MSFT','AAPL','AMZN','GOOGL','META','AVGO','QCOM','INTC','TSM','MRVL','LRCX','AMAT'];
const POLL_MS = 60000;
const SNAPSHOT_INTERVAL_MS = 15 * 60 * 1000; // 15 minutes

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let S = {
  // API Keys
  apiKey: localStorage.getItem('finnhub_key') || '',
  supabaseUrl: '',
  supabaseKey: '',
  supabase: null,
  
  // Connection state
  wsConnected: false,
  mode: 'polling',
  
  // Ticker data
  tickers: [...DEFAULT_TICKERS],
  tickerData: {}, // Dynamic ticker metadata (replaces hardcoded META)
  prices: {},
  prevSnapshot: {},
  
  // Market data
  market: { vix:0, vixPrev:0, sp500:0, sp500Prev:0, ndx:0, ndxPrev:0, fearGreed:35 },
  
  // UI state
  currentTab: (()=>{const p=window.location.pathname.replace(/^\/+/,'').split('/')[0];return ['signals','trading','performance'].includes(p)?p:'signals'})(),
  selected: 'NVDA',
  prevSelected: null,
  weights: JSON.parse(localStorage.getItem('signal_weights') || '{"technical":25,"value":20,"catalyst":20,"volatility":15,"momentum":20}'),
  
  // Polling state
  lastPoll: null,
  wsLast: null,
  refreshCount: 0,
  countdown: 60,
  lastSnapshotSave: 0,
  
  // Paper trading
  portfolio: { cash: 10000, startingCapital: 10000 },
  positions: [], // { id, ticker, shares, entryPrice, entryDate, stopLoss, trailStop, trailHigh, takeProfit, maxExitDate, strategy, signalAtEntry, confluenceVotes }
  tradeHistory: [], // { id, ticker, shares, entryPrice, exitPrice, entryDate, exitDate, pnl, pnlPercent, signalAtEntry, exitReason }
  
  // Auto trading â€” all 3 strategies run simultaneously
  autoTradeEnabled: JSON.parse(localStorage.getItem('ares_auto_trade') || 'true'),
  lastAutoTradeCheck: 0,
  
  // Performance tracking
  portfolioHistory: [], // { date, value }
  signalAccuracy: { '1d': { correct: 0, total: 0 }, '7d': { correct: 0, total: 0 }, '30d': { correct: 0, total: 0 } },
  
  // Search
  searchResults: [],
  searchLoading: false,
  
  structureBuilt: false,
};

let ws = null;
let searchDebounce = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SUPABASE CLIENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class SupabaseClient {
  constructor(url, key) {
    this.url = url;
    this.key = key;
    this.headers = {
      'apikey': key,
      'Authorization': `Bearer ${key}`,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    };
  }

  async from(table) {
    return new SupabaseQuery(this, table);
  }

  async query(table, method, body = null, filters = '') {
    const url = `${this.url}/rest/v1/${table}${filters}`;
    const opts = { method, headers: this.headers };
    if (body) opts.body = JSON.stringify(body);
    try {
      const r = await fetch(url, opts);
      if (!r.ok) {
        const err = await r.text();
        console.error('Supabase error:', err);
        return { data: null, error: err };
      }
      const data = method === 'DELETE' ? null : await r.json();
      return { data, error: null };
    } catch (e) {
      console.error('Supabase error:', e);
      return { data: null, error: e.message };
    }
  }

  async select(table, filters = '') {
    return this.query(table, 'GET', null, filters ? `?${filters}` : '');
  }

  async insert(table, data) {
    return this.query(table, 'POST', data);
  }

  async update(table, data, filters) {
    return this.query(table, 'PATCH', data, `?${filters}`);
  }

  async delete(table, filters) {
    return this.query(table, 'DELETE', null, `?${filters}`);
  }

  async upsert(table, data, onConflict) {
    const url = `${this.url}/rest/v1/${table}`;
    const headers = { ...this.headers, 'Prefer': 'resolution=merge-duplicates,return=representation' };
    try {
      const r = await fetch(url, { method: 'POST', headers, body: JSON.stringify(data) });
      const result = await r.json();
      return { data: result, error: r.ok ? null : result };
    } catch (e) {
      return { data: null, error: e.message };
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SCORING ENGINE (fully dynamic)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getTickerMeta(ticker) {
  return S.tickerData[ticker] || {
    name: ticker,
    color: '#3B82F6',
    sma50: 0,
    sma200: 0,
    support: 0,
    resistance: 0,
    ath: 0,
    earningsDate: null,
    earningsImportance: 50,
    analystTarget: 0,
    analystBuy: 0,
    analystSell: 0,
    forwardPe: 0,
    pegRatio: 1,
    ivPctile: 50,
    sentiment: 50,
    beta: 1,
    notes: '',
    _live: {},
    sparkData: [], // last 30 daily closes for sparkline
    sma20: 0,
    roc5: 0, // 5-day rate of change %
    roc20: 0, // 20-day rate of change %
  };
}

function rsiProxy(price, sma50, ticker) {
  const m = getTickerMeta(ticker);
  if (m._live?.rsi != null) return m._live.rsi;
  if (!sma50 || sma50 === 0) return 50;
  const d = ((price - sma50) / sma50) * 100;
  if (d < -15) return 22;
  if (d < -10) return 28;
  if (d < -5) return 35;
  if (d < -2) return 40;
  if (d < 2) return 48;
  if (d < 5) return 55;
  if (d < 10) return 62;
  return 70;
}

function techScore(price, m, ticker) {
  let s = 0;
  const rsi = rsiProxy(price, m.sma50, ticker);
  
  // RSI scoring
  if (rsi <= 30) s += 30;
  else if (rsi <= 40) s += 22;
  else if (rsi <= 50) s += 12;
  else if (rsi <= 60) s += 5;
  
  // Distance from SMA50
  if (m.sma50 > 0) {
    const d50 = ((price - m.sma50) / m.sma50) * 100;
    if (d50 < -15) s += 25;
    else if (d50 < -10) s += 20;
    else if (d50 < -5) s += 15;
    else if (d50 < 0) s += 8;
  }
  
  // Distance from SMA200 (trend)
  if (m.sma200 > 0) {
    const d200 = ((price - m.sma200) / m.sma200) * 100;
    if (d200 > 20) s += 10;
    else if (d200 > 10) s += 15;
    else if (d200 > 0) s += 20;
    else s += 5;
  }
  
  // Support proximity
  if (m.support > 0) {
    const ds = ((price - m.support) / m.support) * 100;
    if (ds < 2) s += 15;
    else if (ds < 5) s += 10;
    else if (ds < 10) s += 5;
  }
  
  // Beta adjustment (higher beta = more volatile = higher potential)
  if (m.beta > 1.5) s += 5;
  
  // Volume confirmation (from our historical DB)
  const volRatio = m._live?.volumeRatio || 1;
  if (volRatio > 1.5 && rsi <= 40) s += 10;  // High volume + oversold = capitulation (bullish)
  else if (volRatio > 1.5 && rsi >= 60) s -= 5; // High volume + overbought = distribution (bearish)
  else if (volRatio < 0.5) s -= 3; // Low volume = weak conviction either way
  
  return { score: Math.min(Math.max(s, 0), 100), rsi };
}

function valScore(price, m) {
  let s = 0;
  
  // ATH drawdown
  if (m.ath > 0) {
    const dd = ((m.ath - price) / m.ath) * 100;
    if (dd > 30) s += 30;
    else if (dd > 20) s += 25;
    else if (dd > 15) s += 18;
    else if (dd > 10) s += 10;
    else s += 3;
  }
  
  // PEG ratio
  if (m.pegRatio > 0) {
    if (m.pegRatio < 0.5) s += 30;
    else if (m.pegRatio < 1) s += 25;
    else if (m.pegRatio < 1.5) s += 15;
    else if (m.pegRatio < 2) s += 8;
  }
  
  // Analyst upside
  if (m.analystTarget > 0 && price > 0) {
    const up = ((m.analystTarget - price) / price) * 100;
    if (up > 50) s += 25;
    else if (up > 30) s += 20;
    else if (up > 20) s += 15;
    else if (up > 10) s += 8;
    else s += 2;
  }
  
  // Buy/sell ratio
  const total = (m.analystBuy || 0) + (m.analystSell || 0);
  if (total > 0) {
    s += Math.round((m.analystBuy / total) * 15);
  }
  
  return Math.min(s, 100);
}

function catScore(m) {
  let s = 0;
  
  // Earnings proximity
  if (m.earningsDate) {
    const dte = Math.round((new Date(m.earningsDate) - new Date()) / (864e5));
    if (dte >= 10 && dte <= 25) s += 40;
    else if (dte >= 5 && dte < 10) s += 25;
    else if (dte >= 25 && dte <= 40) s += 20;
    else if (dte > 40) s += 10;
    else s += 5;
    return { score: Math.min(s + Math.round((m.earningsImportance || 50) * 0.35) + Math.round((m.sentiment || 50) * 0.25), 100), dte };
  }
  
  // No earnings date â€” neutral
  s = 30 + Math.round((m.sentiment || 50) * 0.25);
  return { score: Math.min(s, 100), dte: null };
}

function momentumScore(price, m) {
  let s = 0;
  
  // Rate of change (5-day)
  if (m.roc5 > 5) s += 10;       // strong short-term momentum
  else if (m.roc5 > 2) s += 15;  // moderate (not overextended)
  else if (m.roc5 > 0) s += 20;  // slight positive
  else if (m.roc5 > -2) s += 12; // slight pullback in uptrend can be ok
  else if (m.roc5 > -5) s += 5;
  // else 0 â€” strong short-term decline
  
  // Rate of change (20-day)
  if (m.roc20 > 10) s += 10;      // extended
  else if (m.roc20 > 5) s += 20;  // healthy momentum
  else if (m.roc20 > 0) s += 15;
  else if (m.roc20 > -5) s += 8;
  else s += 3;
  
  // Position in 52-week range
  if (m.ath > 0 && m.atl > 0 && m.ath > m.atl) {
    const range = m.ath - m.atl;
    const pos = (price - m.atl) / range; // 0 = at low, 1 = at high
    // Sweet spot: 0.3-0.6 (not at bottom, not overextended)
    if (pos >= 0.3 && pos <= 0.6) s += 25;
    else if (pos >= 0.2 && pos <= 0.7) s += 18;
    else if (pos < 0.2) s += 10; // near bottom, could be falling knife
    else s += 5; // near top
  }
  
  // Price vs SMA20 (short-term trend)
  if (m.sma20 > 0) {
    const d20 = ((price - m.sma20) / m.sma20) * 100;
    if (d20 > 0 && d20 < 5) s += 20;  // above but not extended
    else if (d20 >= 5) s += 10;        // extended above
    else if (d20 > -3) s += 15;        // slight pullback to SMA
    else s += 5;                        // well below
  }
  
  return Math.min(s, 100);
}

// Trend filter â€” prevents catching falling knives
function trendFilter(price, m) {
  const aboveSMA50 = m.sma50 > 0 ? price > m.sma50 : true;
  const aboveSMA200 = m.sma200 > 0 ? price > m.sma200 : true;
  const aboveSMA20 = m.sma20 > 0 ? price > m.sma20 : true;
  
  if (aboveSMA50 && aboveSMA200) return { regime: 'uptrend', cap: 100, label: 'ğŸŸ¢ Uptrend' };
  if (aboveSMA200 && !aboveSMA50) return { regime: 'pullback', cap: 75, label: 'ğŸŸ¡ Pullback' };
  if (!aboveSMA200 && aboveSMA50) return { regime: 'recovery', cap: 70, label: 'ğŸ”µ Recovery' };
  // Below both SMAs
  if (m.roc5 > 0 && aboveSMA20) return { regime: 'bounce', cap: 55, label: 'âš¡ Bounce' };
  return { regime: 'downtrend', cap: 50, label: 'ğŸ”´ Downtrend' };
}

function volScore(vix, vixPrev, fg, ivp, beta = 1) {
  let s = 0;
  
  // VIX level
  if (vix > 30) s += 35;
  else if (vix > 25) s += 30;
  else if (vix > 20) s += 22;
  else if (vix > 18) s += 15;
  else if (vix > 15) s += 8;
  
  // VIX trend
  if (vixPrev && vix > vixPrev) s += 15;
  else if (vix > 16.5) s += 8;
  
  // IV percentile
  if (ivp > 80) s += 25;
  else if (ivp > 60) s += 18;
  else if (ivp > 40) s += 10;
  else s += 3;
  
  // Fear & Greed
  if (fg < 20) s += 25;
  else if (fg < 30) s += 20;
  else if (fg < 40) s += 12;
  else if (fg < 50) s += 5;
  
  return Math.min(s, 100);
}

function calcAll(ticker) {
  const p = S.prices[ticker];
  if (!p || !p.price) return null;
  const m = getTickerMeta(ticker);
  
  const t = techScore(p.price, m, ticker);
  const v = valScore(p.price, m);
  const c = catScore(m);
  const vol = volScore(S.market.vix, S.market.vixPrev, S.market.fearGreed, m.ivPctile || 50, m.beta);
  const mom = momentumScore(p.price, m);
  const trend = trendFilter(p.price, m);
  
  const w = S.weights;
  // 5-factor weighted composite (weights sum to 100)
  const totalW = w.technical + w.value + w.catalyst + w.volatility + (w.momentum || 0);
  const rawComp = (t.score * w.technical + v * w.value + c.score * w.catalyst + vol * w.volatility + mom * (w.momentum || 0)) / totalW;
  
  // Apply trend filter cap
  const comp = Math.min(rawComp, trend.cap);
  
  return { tech: t.score, rsi: t.rsi, val: v, cat: c.score, dte: c.dte, vol, mom, trend, rawComp, comp };
}

function sig(comp) {
  if (comp >= 65) return { label: 'STRONG BUY', color: '#00E676', bg: '#00E67612' };
  if (comp >= 55) return { label: 'BUY', color: '#4CAF50', bg: '#4CAF5012' };
  if (comp >= 45) return { label: 'ACCUMULATE', color: '#FFC107', bg: '#FFC10712' };
  if (comp >= 30) return { label: 'WAIT', color: '#FF9800', bg: '#FF980012' };
  return { label: 'AVOID', color: '#F44336', bg: '#F4433612' };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFLUENCE SCORING (v10.1)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcConfluence(ticker) {
  const p = S.prices[ticker];
  if (!p || !p.price) return { votes: 0, factors: [] };
  const m = getTickerMeta(ticker);
  const price = p.price;
  let votes = 0;
  const factors = [];
  
  // 1. RSI oversold
  const rsi = rsiProxy(price, m.sma50, ticker);
  if (rsi <= 35) { votes++; factors.push('RSIâ‰¤35'); }
  
  // 2. Near SMA50 support
  if (m.sma50 > 0) {
    const d50 = ((price - m.sma50) / m.sma50) * 100;
    if (d50 > -8 && d50 < 0) { votes++; factors.push('Near SMA50'); }
  }
  
  // 3. Above SMA200
  if (m.sma200 > 0 && price > m.sma200) { votes++; factors.push('Above SMA200'); }
  
  // 4. Momentum stabilizing
  if (m.roc5 !== undefined && m.roc5 > -3 && m.roc5 < 3 && (m.roc20 === undefined || m.roc20 > -5)) {
    votes++; factors.push('Stabilizing');
  }
  
  // 5. Volume capitulation
  const volRatio = m._live?.volumeRatio || 1;
  if (volRatio > 1.3 && rsi < 45) { votes++; factors.push('Vol+Oversold'); }
  
  // 6. Good PEG
  if (m.pegRatio > 0 && m.pegRatio < 1.5) { votes++; factors.push('PEG<1.5'); }
  
  // 7. Earnings beat history
  if (m._beatRate >= 0.75) { votes++; factors.push('Beatsâ‰¥75%'); }
  
  // 8. 52w range sweet spot
  if (m.ath > 0 && m.atl > 0 && m.ath > m.atl) {
    const pos = (price - m.atl) / (m.ath - m.atl);
    if (pos >= 0.2 && pos <= 0.6) { votes++; factors.push('52w Sweet'); }
  }
  
  // 9. Low volatility
  if (m.beta && m.beta < 1.5) { votes++; factors.push('Low Vol'); }
  
  return { votes, factors };
}

// Multi-Strategy Model Configs
const STRATEGIES = {
  patient: { name: 'Patient', hold: 20, trailStart: 2.5, trailDist: 2.5, stopMult: 1.5, tpPct: 0.25,
    sizing: { 6: 0.15, 7: 0.30, 8: 0.50, 9: 0.90 }, alloc: 0.40 },
  hybrid: { name: 'Hybrid', hold: 10, trailStart: 1.5, trailDist: 1.8, stopMult: 1.2, tpPct: 0.12,
    sizing: { 6: 0.20, 7: 0.35, 8: 0.55, 9: 0.90 }, alloc: 0.35 },
  shortterm: { name: 'ShortTerm', hold: 10, trailStart: 2.0, trailDist: 2.0, stopMult: 1.5, tpPct: 0.15,
    sizing: { 6: 0.15, 7: 0.30, 8: 0.50, 9: 0.90 }, alloc: 0.25 },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FINNHUB API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fhGet(endpoint) {
  const key = S.apiKey;
  if (!key) return null;
  try {
    const r = await fetch(`https://finnhub.io/api/v1${endpoint}${endpoint.includes('?') ? '&' : '?'}token=${key}`, { signal: AbortSignal.timeout(8000) });
    if (!r.ok) return null;
    return await r.json();
  } catch (e) {
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PHASE 1: SEARCH + DYNAMIC SCORING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function searchTickers(query) {
  if (!query || query.length < 1) {
    S.searchResults = [];
    updateSearchResults();
    return;
  }
  
  S.searchLoading = true;
  updateSearchResults();
  
  const data = await fhGet(`/search?q=${encodeURIComponent(query)}`);
  
  if (data?.result) {
    // Filter to common stock only, limit to 10
    S.searchResults = data.result
      .filter(r => r.type === 'Common Stock' && !r.symbol.includes('.'))
      .slice(0, 10);
  } else {
    S.searchResults = [];
  }
  
  S.searchLoading = false;
  updateSearchResults();
}

async function fetchTickerData(ticker) {
  // Fetch all available data for a ticker
  const [quote, profile, metrics, priceTarget, recommendations, earnings] = await Promise.all([
    fhGet(`/quote?symbol=${ticker}`),
    fhGet(`/stock/profile2?symbol=${ticker}`),
    fhGet(`/stock/metric?symbol=${ticker}&metric=all`),
    fhGet(`/stock/price-target?symbol=${ticker}`),
    fhGet(`/stock/recommendation?symbol=${ticker}`),
    fhGet(`/calendar/earnings?symbol=${ticker}`)
  ]);
  
  const meta = getTickerMeta(ticker);
  
  // Profile data
  if (profile) {
    meta.name = profile.name || ticker;
    meta.sector = profile.finnhubIndustry || '';
    meta.marketCap = profile.marketCapitalization || 0;
    meta.logo = profile.logo || '';
    // Generate color from ticker name
    meta.color = `hsl(${ticker.split('').reduce((a, c) => a + c.charCodeAt(0), 0) % 360}, 70%, 50%)`;
  }
  
  // Metrics data
  if (metrics?.metric) {
    const m = metrics.metric;
    meta.ath = m['52WeekHigh'] || 0;
    meta.atl = m['52WeekLow'] || 0;
    meta.forwardPe = m['forwardPE'] || m['peBasicExclExtraTTM'] || 0;
    meta.pegRatio = m['pegRatio'] || 1;
    meta.beta = m['beta'] || 1;
    
    // Use 52w low as support proxy
    meta.support = m['52WeekLow'] || 0;
    meta.resistance = m['52WeekHigh'] || 0;
    
    // Calculate IV percentile from beta (rough proxy)
    meta.ivPctile = Math.min(100, Math.max(0, (meta.beta - 0.5) * 50));
  }
  
  // Price target
  if (priceTarget) {
    meta.analystTarget = priceTarget.targetMedian || priceTarget.targetMean || 0;
  }
  
  // Recommendations
  if (recommendations && recommendations.length > 0) {
    const latest = recommendations[0];
    meta.analystBuy = (latest.strongBuy || 0) + (latest.buy || 0);
    meta.analystSell = (latest.strongSell || 0) + (latest.sell || 0);
    meta.sentiment = Math.round(meta.analystBuy / (meta.analystBuy + meta.analystSell + 0.01) * 100);
  }
  
  // Earnings
  if (earnings?.earningsCalendar?.length > 0) {
    const upcoming = earnings.earningsCalendar.find(e => new Date(e.date) > new Date());
    if (upcoming) {
      meta.earningsDate = upcoming.date;
      meta.earningsImportance = upcoming.epsEstimate ? 75 : 50;
    }
  }
  
  // Quote data
  if (quote && quote.c) {
    S.prices[ticker] = {
      price: quote.c,
      prevClose: quote.pc,
      high: quote.h,
      low: quote.l,
      open: quote.o,
      source: 'finnhub-rest'
    };
  }
  
  S.tickerData[ticker] = meta;
  return meta;
}

async function addTicker(ticker) {
  ticker = ticker.toUpperCase();
  if (S.tickers.includes(ticker)) {
    S.selected = ticker;
    buildStructure();
    updateNumbers();
    return;
  }
  
  // Fetch data
  await fetchTickerData(ticker);
  
  // Add to list
  S.tickers.push(ticker);
  S.selected = ticker;
  
  // Save to Supabase watchlist
  if (S.supabase) {
    await S.supabase.upsert('watchlist', { symbol: ticker, added_at: new Date().toISOString() });
  }
  
  // Subscribe to WS
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'subscribe', symbol: ticker }));
  }
  
  // Fetch RSI and options
  fetchHistoricalRSI(ticker);
  fetchOptionsData(ticker);
  
  buildStructure();
  updateNumbers();
}

async function removeTicker(ticker) {
  const idx = S.tickers.indexOf(ticker);
  if (idx === -1 || DEFAULT_TICKERS.includes(ticker)) return;
  
  S.tickers.splice(idx, 1);
  delete S.tickerData[ticker];
  delete S.prices[ticker];
  
  if (S.selected === ticker) {
    S.selected = S.tickers[0] || 'NVDA';
  }
  
  // Remove from Supabase
  if (S.supabase) {
    await S.supabase.delete('watchlist', `symbol=eq.${ticker}`);
  }
  
  // Unsubscribe from WS
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'unsubscribe', symbol: ticker }));
  }
  
  buildStructure();
  updateNumbers();
}

function updateSearchResults() {
  const el = document.getElementById('search-results');
  if (!el) return;
  
  if (S.searchLoading) {
    el.innerHTML = '<div class="search-result"><span class="spinner">âŸ³</span> Searching...</div>';
    el.classList.add('show');
    return;
  }
  
  if (S.searchResults.length === 0) {
    el.classList.remove('show');
    return;
  }
  
  el.innerHTML = S.searchResults.map(r => `
    <div class="search-result" onclick="addTicker('${r.symbol}'); hideSearch();">
      <div>
        <span class="sym mono">${r.symbol}</span>
        <span class="desc">${r.description}</span>
      </div>
      <span class="mono" style="color:var(--text-3)">${S.tickers.includes(r.symbol) ? 'âœ“' : '+'}</span>
    </div>
  `).join('');
  el.classList.add('show');
}

function hideSearch() {
  const el = document.getElementById('search-results');
  if (el) el.classList.remove('show');
  const input = document.getElementById('search-input');
  if (input) input.value = '';
  S.searchResults = [];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DATA FETCHING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function pollFinnhub() {
  // Snapshot previous prices
  for (const t of S.tickers) {
    if (S.prices[t]?.price) S.prevSnapshot[t] = S.prices[t].price;
  }
  
  // Fetch all ticker quotes + market indices
  const allSymbols = [...S.tickers, 'SPY', 'QQQ', 'VIXY'];
  const quotePromises = allSymbols.map(sym =>
    fhGet(`/quote?symbol=${sym}`).then(d => d ? { sym, ...d } : null)
  );
  const results = await Promise.all(quotePromises);
  
  for (const q of results) {
    if (!q || !q.c) continue;
    const sym = q.sym;
    
    if (S.tickers.includes(sym)) {
      const existing = S.prices[sym] || {};
      const wsAge = existing?.lastTrade ? (Date.now() - existing.lastTrade) : 999999;
      if (wsAge > 30000) {
        S.prices[sym] = { ...existing, price: q.c, prevClose: q.pc, high: q.h, low: q.l, open: q.o, source: 'finnhub-rest' };
      } else {
        S.prices[sym] = { ...existing, prevClose: q.pc, high: Math.max(q.h || 0, existing.high || 0), low: Math.min(q.l || 999999, existing.low || 999999), open: q.o };
      }
    }
    
    if (sym === 'VIXY') { S.market.vix = q.c; S.market.vixPrev = q.pc; }
    if (sym === 'SPY') { S.market.sp500 = q.c; S.market.sp500Prev = q.pc; }
    if (sym === 'QQQ') { S.market.ndx = q.c; S.market.ndxPrev = q.pc; }
  }
  
  S.lastPoll = new Date();
  S.refreshCount++;
  S.countdown = 60;
  
  updateNumbers();
  updatePositionPnL();
  runAutoTrade();
  
  // Save signal snapshots every 15 minutes
  if (Date.now() - S.lastSnapshotSave >= SNAPSHOT_INTERVAL_MS) {
    saveSignalSnapshots();
    S.lastSnapshotSave = Date.now();
  }
}

async function fetchOptionsData(ticker = null) {
  const tickers = ticker ? [ticker] : S.tickers;
  
  for (const t of tickers) {
    try {
      const d = await fhGet(`/stock/option-chain?symbol=${t}`);
      if (!d?.data?.length) continue;
      
      const nearest = d.data[0];
      const calls = nearest.options?.CALL || [];
      const puts = nearest.options?.PUT || [];
      const totalCallOI = calls.reduce((a, o) => a + (o.openInterest || 0), 0);
      const totalPutOI = puts.reduce((a, o) => a + (o.openInterest || 0), 0);
      const pcRatio = totalCallOI > 0 ? (totalPutOI / totalCallOI) : null;
      const totalCallVol = calls.reduce((a, o) => a + (o.volume || 0), 0);
      const totalPutVol = puts.reduce((a, o) => a + (o.volume || 0), 0);
      
      if (!S.tickerData[t]) S.tickerData[t] = getTickerMeta(t);
      if (!S.tickerData[t]._live) S.tickerData[t]._live = {};
      S.tickerData[t]._live.pcRatio = pcRatio;
      S.tickerData[t]._live.callOI = totalCallOI;
      S.tickerData[t]._live.putOI = totalPutOI;
      S.tickerData[t]._live.callVol = totalCallVol;
      S.tickerData[t]._live.putVol = totalPutVol;
    } catch (e) { continue; }
  }
  updateNumbers();
}

async function fetchHistoricalRSI(ticker = null) {
  const tickers = ticker ? [ticker] : S.tickers;
  
  for (const t of tickers) {
    try {
      // PRIMARY: Fetch from our Supabase historical DB (200+ days, reliable)
      let clean = [], volumes = [];
      if (S.supabase) {
        const { data } = await S.supabase.select('daily_prices', `ticker=eq.${t}&order=date.asc&limit=250`);
        if (data?.length > 15) {
          clean = data.map(d => parseFloat(d.close));
          volumes = data.map(d => parseInt(d.volume) || 0);
        }
      }
      
      // FALLBACK: Yahoo via CORS proxy (for new tickers not in our DB)
      if (clean.length < 15) {
        const end = Math.floor(Date.now() / 1000);
        const start = end - (90 * 86400);
        const url = `https://corsproxy.io/?url=${encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${t}?period1=${start}&period2=${end}&interval=1d`)}`;
        const r = await fetch(url, { signal: AbortSignal.timeout(10000) });
        if (r.ok) {
          const d = await r.json();
          const rawCloses = d?.chart?.result?.[0]?.indicators?.quote?.[0]?.close;
          const rawVols = d?.chart?.result?.[0]?.indicators?.quote?.[0]?.volume;
          if (rawCloses?.length > 15) {
            clean = rawCloses.filter(c => c != null);
            volumes = rawVols ? rawVols.filter(v => v != null) : [];
          }
        }
      }
      
      if (clean.length < 15) continue;
      
      // RSI(14)
      let gains = 0, losses = 0;
      for (let i = 1; i <= 14 && i < clean.length; i++) {
        const diff = clean[i] - clean[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / 14, avgLoss = losses / 14;
      for (let i = 15; i < clean.length; i++) {
        const diff = clean[i] - clean[i - 1];
        avgGain = (avgGain * 13 + (diff > 0 ? diff : 0)) / 14;
        avgLoss = (avgLoss * 13 + (diff < 0 ? -diff : 0)) / 14;
      }
      const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
      const rsi = 100 - (100 / (1 + rs));
      
      if (!S.tickerData[t]) S.tickerData[t] = getTickerMeta(t);
      if (!S.tickerData[t]._live) S.tickerData[t]._live = {};
      S.tickerData[t]._live.rsi = Math.round(rsi * 10) / 10;
      S.tickerData[t]._live.rsiSource = clean.length >= 200 ? 'db-200d' : 'db-partial';
      
      // SMAs from historical data
      if (clean.length >= 20) {
        S.tickerData[t].sma20 = Math.round(clean.slice(-20).reduce((a, b) => a + b, 0) / 20 * 100) / 100;
      }
      if (clean.length >= 50) {
        S.tickerData[t].sma50 = Math.round(clean.slice(-50).reduce((a, b) => a + b, 0) / 50 * 100) / 100;
      }
      // REAL SMA200 â€” now possible with 200+ days in our DB!
      if (clean.length >= 200) {
        S.tickerData[t].sma200 = Math.round(clean.slice(-200).reduce((a, b) => a + b, 0) / 200 * 100) / 100;
      } else if (clean.length >= 60) {
        S.tickerData[t].sma200 = S.tickerData[t].sma200 || Math.round(clean.reduce((a, b) => a + b, 0) / clean.length * 100) / 100;
      }
      
      // Rate of change
      if (clean.length >= 6) {
        S.tickerData[t].roc5 = Math.round(((clean[clean.length-1] - clean[clean.length-6]) / clean[clean.length-6]) * 10000) / 100;
      }
      if (clean.length >= 21) {
        S.tickerData[t].roc20 = Math.round(((clean[clean.length-1] - clean[clean.length-21]) / clean[clean.length-21]) * 10000) / 100;
      }
      
      // Spark data â€” last 30 closes for sparkline
      S.tickerData[t].sparkData = clean.slice(-30);
      
      // Volume analysis
      if (volumes.length >= 20) {
        const avgVol20 = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
        const todayVol = volumes[volumes.length - 1];
        S.tickerData[t]._live.avgVolume20 = Math.round(avgVol20);
        S.tickerData[t]._live.volumeRatio = avgVol20 > 0 ? Math.round((todayVol / avgVol20) * 100) / 100 : 1;
      }
      
      // ATL from data if not set
      if (!S.tickerData[t].atl || S.tickerData[t].atl === 0) {
        S.tickerData[t].atl = Math.min(...clean);
      }
    } catch (e) { continue; }
  }
  updateNumbers();
}

// Alpha Vantage real indicators (25 calls/day â€” use sparingly, once on load)
async function fetchAlphaVantageIndicators() {
  const tickers = S.tickers.slice(0, 5); // Max 5 to conserve API calls
  
  for (const t of tickers) {
    try {
      // Fetch RSI(14) â€” real calculation from Alpha Vantage
      const rsiData = await fetch(`/api/indicators?symbol=${t}&indicator=RSI&period=14`, { signal: AbortSignal.timeout(10000) });
      if (rsiData.ok) {
        const d = await rsiData.json();
        const key = 'Technical Analysis: RSI';
        if (d[key]) {
          const dates = Object.keys(d[key]).sort().reverse();
          if (dates.length) {
            const realRsi = parseFloat(d[key][dates[0]].RSI);
            if (!S.tickerData[t]) S.tickerData[t] = getTickerMeta(t);
            if (!S.tickerData[t]._live) S.tickerData[t]._live = {};
            S.tickerData[t]._live.rsi = Math.round(realRsi * 10) / 10;
            S.tickerData[t]._live.rsiSource = 'alpha-vantage';
          }
        }
      }
      
      // Fetch SMA200 â€” real calculation
      const smaData = await fetch(`/api/indicators?symbol=${t}&indicator=SMA&period=200`, { signal: AbortSignal.timeout(10000) });
      if (smaData.ok) {
        const d = await smaData.json();
        const key = 'Technical Analysis: SMA';
        if (d[key]) {
          const dates = Object.keys(d[key]).sort().reverse();
          if (dates.length) {
            S.tickerData[t].sma200 = parseFloat(d[key][dates[0]].SMA);
          }
        }
      }
      
      // Fetch SMA50
      const sma50Data = await fetch(`/api/indicators?symbol=${t}&indicator=SMA&period=50`, { signal: AbortSignal.timeout(10000) });
      if (sma50Data.ok) {
        const d = await sma50Data.json();
        const key = 'Technical Analysis: SMA';
        if (d[key]) {
          const dates = Object.keys(d[key]).sort().reverse();
          if (dates.length) {
            S.tickerData[t].sma50 = parseFloat(d[key][dates[0]].SMA);
          }
        }
      }
    } catch (e) { continue; }
  }
  updateNumbers();
}

async function fetchFearGreed() {
  try {
    const r = await fetch('https://api.alternative.me/fng/?limit=1', { signal: AbortSignal.timeout(5000) });
    const d = await r.json();
    if (d?.data?.[0]) {
      S.market.fearGreed = parseInt(d.data[0].value);
    }
  } catch (e) { }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NEWS SENTIMENT (Finnhub company-news)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BULLISH_WORDS = ['beat','surge','rally','upgrade','raise','buy','bullish','outperform','record','growth','strong','profit','soar','breakout','momentum'];
const BEARISH_WORDS = ['miss','crash','sell','downgrade','cut','bearish','underperform','decline','loss','weak','warning','risk','plunge','layoff','recall'];

async function fetchNewsSentiment() {
  for (const t of S.tickers) {
    try {
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date(Date.now() - 7 * 86400000).toISOString().split('T')[0];
      const data = await fhGet(`/company-news?symbol=${t}&from=${weekAgo}&to=${today}`);
      if (!data?.length) continue;
      
      // Score headlines
      let totalScore = 0;
      const headlines = data.slice(0, 20); // Last 20 articles
      for (const article of headlines) {
        const text = (article.headline || '').toLowerCase();
        let score = 0;
        for (const w of BULLISH_WORDS) { if (text.includes(w)) score += 1; }
        for (const w of BEARISH_WORDS) { if (text.includes(w)) score -= 1; }
        totalScore += score;
      }
      
      // Normalize to 0-100 scale (50 = neutral)
      const normalized = Math.min(100, Math.max(0, 50 + (totalScore / headlines.length) * 25));
      
      if (!S.tickerData[t]) S.tickerData[t] = getTickerMeta(t);
      S.tickerData[t].sentiment = Math.round(normalized);
      S.tickerData[t]._live.newsCount = headlines.length;
      S.tickerData[t]._live.newsSentiment = Math.round(normalized);
      S.tickerData[t]._live.latestHeadline = headlines[0]?.headline || '';
      
      // Save to Supabase for tracking
      if (S.supabase && headlines.length) {
        const rows = headlines.slice(0, 5).map(h => ({
          ticker: t,
          headline: h.headline,
          source: h.source,
          url: h.url,
          sentiment_score: 0,
          published_at: new Date(h.datetime * 1000).toISOString()
        }));
        S.supabase.query('news_sentiment', 'POST', rows);
      }
    } catch (e) { continue; }
  }
  updateNumbers();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PHASE 2: SUPABASE INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function loadServerConfig() {
  try {
    const r = await fetch('/api/config', { signal: AbortSignal.timeout(3000) });
    if (r.ok) {
      const d = await r.json();
      if (d.fk && !S.apiKey) {
        S.apiKey = d.fk;
        localStorage.setItem('finnhub_key', d.fk);
      }
      if (d.sbUrl && d.sbKey) {
        S.supabaseUrl = d.sbUrl;
        S.supabaseKey = d.sbKey;
        S.supabase = new SupabaseClient(d.sbUrl, d.sbKey);
        await loadFromSupabase();
      }
    }
  } catch (e) { console.error('Config load error:', e); }
}

async function loadFromSupabase() {
  if (!S.supabase) return;
  
  try {
    // Load watchlist
    const { data: watchlist } = await S.supabase.select('watchlist', 'order=added_at.asc');
    if (watchlist?.length > 0) {
      const savedTickers = watchlist.map(w => w.symbol);
      // Merge with defaults
      for (const t of savedTickers) {
        if (!S.tickers.includes(t)) S.tickers.push(t);
      }
    }
    
    // Load portfolio
    const { data: portfolio } = await S.supabase.select('portfolio', 'order=id.asc&limit=1');
    if (portfolio?.length > 0) {
      S.portfolio.cash = portfolio[0].cash || 10000;
      S.portfolio.startingCapital = portfolio[0].starting_capital || 10000;
    }
    
    // Load open positions
    const { data: positions } = await S.supabase.select('paper_trades', 'status=eq.open&order=entry_date.desc');
    if (positions) {
      S.positions = positions.map(p => ({
        id: p.id,
        ticker: p.symbol,
        shares: p.shares,
        entryPrice: p.entry_price,
        entryDate: p.entry_date,
        stopLoss: p.stop_loss,
        signalAtEntry: p.signal_at_entry
      }));
    }
    
    // Load trade history
    const { data: history } = await S.supabase.select('paper_trades', 'status=eq.closed&order=exit_date.desc&limit=50');
    if (history) {
      S.tradeHistory = history.map(h => ({
        id: h.id,
        ticker: h.symbol,
        shares: h.shares,
        entryPrice: h.entry_price,
        exitPrice: h.exit_price,
        entryDate: h.entry_date,
        exitDate: h.exit_date,
        pnl: h.pnl,
        pnlPercent: h.pnl_percent,
        signalAtEntry: h.signal_at_entry
      }));
    }
    
    // Load portfolio history
    const { data: historyData } = await S.supabase.select('portfolio', 'order=created_at.asc');
    if (historyData) {
      S.portfolioHistory = historyData.map(h => ({
        date: h.created_at,
        value: h.total_value || (h.cash || 10000)
      }));
    }
    
  } catch (e) { console.error('Supabase load error:', e); }
}

async function saveSignalSnapshots() {
  if (!S.supabase) return;
  
  const snapshots = [];
  for (const ticker of S.tickers) {
    const sc = calcAll(ticker);
    const p = S.prices[ticker];
    if (!sc || !p?.price) continue;
    
    snapshots.push({
      symbol: ticker,
      price: p.price,
      composite_score: sc.comp,
      tech_score: sc.tech,
      value_score: sc.val,
      catalyst_score: sc.cat,
      volatility_score: sc.vol,
      rsi: sc.rsi,
      signal: sig(sc.comp).label,
      created_at: new Date().toISOString()
    });
  }
  
  if (snapshots.length > 0) {
    for (const snap of snapshots) {
      await S.supabase.insert('signal_snapshots', snap);
    }
  }
}

async function savePortfolio() {
  if (!S.supabase) return;
  
  const totalValue = calculatePortfolioValue();
  await S.supabase.insert('portfolio', {
    cash: S.portfolio.cash,
    starting_capital: S.portfolio.startingCapital,
    total_value: totalValue,
    created_at: new Date().toISOString()
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PHASE 3: PAPER TRADING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calculatePortfolioValue() {
  let value = S.portfolio.cash;
  for (const pos of S.positions) {
    const price = S.prices[pos.ticker]?.price || pos.entryPrice;
    value += pos.shares * price;
  }
  return value;
}

function updatePositionPnL() {
  // Check stop losses
  for (const pos of S.positions) {
    const price = S.prices[pos.ticker]?.price;
    if (price && pos.stopLoss && price <= pos.stopLoss) {
      // Auto-close at stop loss
      closePosition(pos.id, true);
    }
  }
}

function openBuyModal(ticker) {
  const price = S.prices[ticker]?.price || 0;
  document.getElementById('modal-ticker').textContent = ticker;
  document.getElementById('modal-price').value = '$' + price.toFixed(2);
  document.getElementById('modal-shares').value = '';
  document.getElementById('modal-stoploss').value = '';
  document.getElementById('modal-total').value = '';
  document.getElementById('buy-modal').classList.add('show');
  
  document.getElementById('modal-shares').oninput = () => {
    const shares = parseInt(document.getElementById('modal-shares').value) || 0;
    document.getElementById('modal-total').value = '$' + (shares * price).toFixed(2);
  };
}

function closeBuyModal() {
  document.getElementById('buy-modal').classList.remove('show');
}

async function executeBuy() {
  const ticker = document.getElementById('modal-ticker').textContent;
  const shares = parseInt(document.getElementById('modal-shares').value) || 0;
  const stopLoss = parseFloat(document.getElementById('modal-stoploss').value) || null;
  const price = S.prices[ticker]?.price || 0;
  const total = shares * price;
  
  if (shares <= 0 || total > S.portfolio.cash) {
    alert('Invalid order: Not enough cash or invalid shares');
    return;
  }
  
  const sc = calcAll(ticker);
  const signal = sc ? sig(sc.comp).label : 'UNKNOWN';
  
  const position = {
    id: Date.now(),
    ticker,
    shares,
    entryPrice: price,
    entryDate: new Date().toISOString(),
    stopLoss,
    signalAtEntry: signal
  };
  
  S.positions.push(position);
  S.portfolio.cash -= total;
  
  // Save to Supabase
  if (S.supabase) {
    await S.supabase.insert('paper_trades', {
      symbol: ticker,
      shares,
      entry_price: price,
      entry_date: position.entryDate,
      stop_loss: stopLoss,
      signal_at_entry: signal,
      status: 'open'
    });
    await savePortfolio();
  }
  
  closeBuyModal();
  buildStructure();
  updateNumbers();
}

function openCloseModal(positionId) {
  const pos = S.positions.find(p => p.id === positionId);
  if (!pos) return;
  
  const price = S.prices[pos.ticker]?.price || pos.entryPrice;
  const pnl = (price - pos.entryPrice) * pos.shares;
  const pnlPercent = ((price - pos.entryPrice) / pos.entryPrice * 100);
  
  document.getElementById('close-modal-ticker').textContent = pos.ticker;
  document.getElementById('close-modal-shares').value = pos.shares;
  document.getElementById('close-modal-price').value = '$' + price.toFixed(2);
  document.getElementById('close-modal-pnl').value = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2) + ' (' + (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%)';
  document.getElementById('close-modal-pnl').style.color = pnl >= 0 ? 'var(--green)' : 'var(--red)';
  document.getElementById('close-modal').dataset.positionId = positionId;
  document.getElementById('close-modal').classList.add('show');
}

function closeCloseModal() {
  document.getElementById('close-modal').classList.remove('show');
}

async function executeClose() {
  const positionId = parseInt(document.getElementById('close-modal').dataset.positionId);
  await closePosition(positionId);
  closeCloseModal();
}

async function closePosition(positionId, isStopLoss = false) {
  const idx = S.positions.findIndex(p => p.id === positionId);
  if (idx === -1) return;
  
  const pos = S.positions[idx];
  const price = S.prices[pos.ticker]?.price || pos.entryPrice;
  const pnl = (price - pos.entryPrice) * pos.shares;
  const pnlPercent = ((price - pos.entryPrice) / pos.entryPrice * 100);
  
  const trade = {
    id: pos.id,
    ticker: pos.ticker,
    shares: pos.shares,
    entryPrice: pos.entryPrice,
    exitPrice: price,
    entryDate: pos.entryDate,
    exitDate: new Date().toISOString(),
    pnl,
    pnlPercent,
    signalAtEntry: pos.signalAtEntry
  };
  
  S.tradeHistory.unshift(trade);
  S.portfolio.cash += pos.shares * price;
  S.positions.splice(idx, 1);
  
  // Save to Supabase
  if (S.supabase) {
    await S.supabase.update('paper_trades', {
      exit_price: price,
      exit_date: trade.exitDate,
      pnl,
      pnl_percent: pnlPercent,
      status: 'closed'
    }, `id=eq.${pos.id}`);
    await savePortfolio();
  }
  
  buildStructure();
  updateNumbers();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AUTO PAPER TRADING ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toggleAutoTrade() {
  S.autoTradeEnabled = !S.autoTradeEnabled;
  localStorage.setItem('ares_auto_trade', JSON.stringify(S.autoTradeEnabled));
  buildStructure();
  updateNumbers();
}

// Check for new entry signals â€” runs ALL 3 strategies simultaneously
function autoTradeEntry() {
  if (!S.autoTradeEnabled) return;
  
  for (const [stratKey, strat] of Object.entries(STRATEGIES)) {
    const stratCapital = S.portfolio.startingCapital * strat.alloc;
    
    for (const ticker of S.tickers) {
      // Skip if already have a position in this ticker FOR THIS STRATEGY
      if (S.positions.some(p => p.ticker === ticker && p.strategy === stratKey)) continue;
      
      const p = S.prices[ticker];
      if (!p?.price) continue;
      
      const conf = calcConfluence(ticker);
      if (conf.votes < 6) continue;
      
      const sc = calcAll(ticker);
      if (!sc || sc.comp < 45) continue;
      
      // Macro filters
      const spyChg = S.market.sp500Prev ? ((S.market.sp500 - S.market.sp500Prev) / S.market.sp500Prev * 100) : 0;
      if (spyChg < -3) continue;
      
      // Skip within 7 days of earnings
      if (sc.dte != null && sc.dte >= 0 && sc.dte <= 7) continue;
      
      // Position sizing by confluence
      const sizePct = strat.sizing[Math.min(conf.votes, 9)] || strat.sizing[6];
      const positionValue = stratCapital * sizePct;
      
      if (positionValue > S.portfolio.cash) continue;
      if (positionValue < 50) continue;
      
      const shares = Math.floor(positionValue / p.price);
      if (shares < 1) continue;
      
      const atrProxy = p.price * 0.02;
      const stopLoss = p.price - (strat.stopMult * atrProxy);
      const takeProfit = p.price * (1 + strat.tpPct);
      const trailActivation = p.price + (strat.trailStart * atrProxy);
      
      const entryDate = new Date();
      const maxExitDate = new Date(entryDate);
      maxExitDate.setDate(maxExitDate.getDate() + strat.hold + Math.ceil(strat.hold * 2 / 5));
      
      const position = {
        id: Date.now() + Math.random(),
        ticker,
        shares,
        entryPrice: p.price,
        entryDate: entryDate.toISOString(),
        stopLoss,
        trailStop: null,
        trailHigh: p.price,
        trailActivation,
        takeProfit,
        maxExitDate: maxExitDate.toISOString(),
        strategy: stratKey,
        signalAtEntry: sig(sc.comp).label,
        confluenceVotes: conf.votes,
        confluenceFactors: conf.factors.join(', '),
        atrProxy
      };
      
      S.positions.push(position);
      S.portfolio.cash -= shares * p.price;
      
      if (S.supabase) {
        S.supabase.insert('paper_trades', {
          ticker, side: 'buy', entry_price: p.price, entry_score: sc.comp,
          entry_signal: sig(sc.comp).label, shares, stop_loss: stopLoss,
          take_profit: takeProfit, status: 'open',
          notes: `Auto: ${stratKey} | ${conf.votes}/9 confluence | Factors: ${conf.factors.join(', ')}`
        });
        savePortfolio();
      }
      
      console.log(`ğŸ¤– AUTO BUY [${strat.name}]: ${ticker} x${shares} @ $${p.price.toFixed(2)} | ${conf.votes}/9 | Stop: $${stopLoss.toFixed(2)} | TP: $${takeProfit.toFixed(2)}`);
    }
  }
}

// Monitor positions and auto-close when exit conditions hit
function autoTradeExit() {
  if (!S.autoTradeEnabled) return;
  
  const toClose = [];
  
  for (const pos of S.positions) {
    const p = S.prices[pos.ticker];
    if (!p?.price) continue;
    
    let exitReason = null;
    
    // 1. Stop loss hit
    if (pos.stopLoss && p.price <= pos.stopLoss) {
      exitReason = 'STOP LOSS';
    }
    
    // 2. Trailing stop
    if (!exitReason && pos.trailStop && p.price <= pos.trailStop) {
      exitReason = 'TRAIL STOP';
    }
    
    // 3. Take profit
    if (!exitReason && pos.takeProfit && p.price >= pos.takeProfit) {
      exitReason = 'TAKE PROFIT';
    }
    
    // 4. Max hold time
    if (!exitReason && pos.maxExitDate && new Date() >= new Date(pos.maxExitDate)) {
      exitReason = 'MAX HOLD';
    }
    
    // Update trailing stop (if price moved enough)
    if (!exitReason && pos.trailActivation) {
      if (p.price > (pos.trailHigh || pos.entryPrice)) {
        pos.trailHigh = p.price;
      }
      if (pos.trailHigh >= pos.trailActivation) {
        const strat = STRATEGIES[pos.strategy] || STRATEGIES.patient;
        const trailDist = (pos.atrProxy || pos.entryPrice * 0.02) * strat.trailDist;
        pos.trailStop = pos.trailHigh - trailDist;
      }
    }
    
    if (exitReason) {
      toClose.push({ pos, exitReason });
    }
  }
  
  for (const { pos, exitReason } of toClose) {
    autoClosePosition(pos.id, exitReason);
  }
}

async function autoClosePosition(positionId, exitReason) {
  const idx = S.positions.findIndex(p => p.id === positionId);
  if (idx === -1) return;
  
  const pos = S.positions[idx];
  const price = S.prices[pos.ticker]?.price || pos.entryPrice;
  const pnl = (price - pos.entryPrice) * pos.shares;
  const pnlPercent = ((price - pos.entryPrice) / pos.entryPrice * 100);
  
  const trade = {
    id: pos.id,
    ticker: pos.ticker,
    shares: pos.shares,
    entryPrice: pos.entryPrice,
    exitPrice: price,
    entryDate: pos.entryDate,
    exitDate: new Date().toISOString(),
    pnl,
    pnlPercent,
    signalAtEntry: pos.signalAtEntry,
    exitReason,
    strategy: pos.strategy,
    confluenceVotes: pos.confluenceVotes
  };
  
  S.tradeHistory.unshift(trade);
  S.portfolio.cash += pos.shares * price;
  S.positions.splice(idx, 1);
  
  // Save to Supabase
  if (S.supabase) {
    await S.supabase.update('paper_trades', {
      exit_price: price,
      exit_at: trade.exitDate,
      pnl,
      pnl_pct: pnlPercent,
      status: 'closed',
      notes: `Exit: ${exitReason} | ${pos.strategy}`
    }, `ticker=eq.${pos.ticker}&status=eq.open`);
    await savePortfolio();
  }
  
  console.log(`ğŸ¤– AUTO ${exitReason}: ${pos.ticker} x${pos.shares} @ $${price.toFixed(2)} | P&L: ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)`);
  
  buildStructure();
  updateNumbers();
}

// Run auto trade check (called from pollFinnhub)
function runAutoTrade() {
  if (!S.autoTradeEnabled) return;
  const now = Date.now();
  if (now - S.lastAutoTradeCheck < 30000) return; // Max once per 30s
  S.lastAutoTradeCheck = now;
  
  autoTradeExit(); // Check exits first
  autoTradeEntry(); // Then look for new entries
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WEBSOCKET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function connectWS() {
  if (!S.apiKey) return;
  if (ws) { ws.close(); ws = null; }
  
  try {
    ws = new WebSocket(`wss://ws.finnhub.io?token=${S.apiKey}`);
    ws.onopen = () => {
      S.wsConnected = true;
      S.mode = 'websocket';
      S.tickers.forEach(t => ws.send(JSON.stringify({ type: 'subscribe', symbol: t })));
      updateStatus();
    };
    ws.onmessage = (evt) => {
      try {
        const msg = JSON.parse(evt.data);
        if (msg.type === 'trade' && msg.data) {
          for (const trade of msg.data) {
            const sym = trade.s;
            if (!S.tickers.includes(sym)) continue;
            const ex = S.prices[sym] || {};
            if (ex.price) S.prevSnapshot[sym] = ex.price;
            S.prices[sym] = {
              ...ex,
              price: trade.p,
              lastTrade: trade.t,
              high: Math.max(ex.high || 0, trade.p),
              low: Math.min(ex.low || 999999, trade.p),
              source: 'finnhub-ws'
            };
          }
          S.wsLast = new Date();
          updateNumbers();
        }
      } catch (e) { }
    };
    ws.onerror = () => { S.wsConnected = false; S.mode = 'polling'; updateStatus(); };
    ws.onclose = () => { S.wsConnected = false; S.mode = 'polling'; updateStatus(); setTimeout(connectWS, 5000); };
  } catch (e) { S.wsConnected = false; S.mode = 'polling'; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WEIGHT HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function adjustWeight(key, newVal) {
  const others = Object.keys(S.weights).filter(k => k !== key);
  const rem = 100 - newVal;
  const curSum = others.reduce((a, k) => a + S.weights[k], 0);
  S.weights[key] = newVal;
  others.forEach(k => { S.weights[k] = curSum > 0 ? Math.round((S.weights[k] / curSum) * rem) : Math.round(rem / 3); });
  const diff = 100 - Object.values(S.weights).reduce((a, b) => a + b, 0);
  if (diff !== 0) S.weights[others[0]] += diff;
  localStorage.setItem('signal_weights', JSON.stringify(S.weights));
  
  others.concat([key]).forEach(k => {
    const el = document.getElementById(`w-val-${k}`);
    if (el) el.textContent = S.weights[k] + '%';
    const sl = document.getElementById(`w-slider-${k}`);
    if (sl) sl.value = S.weights[k];
  });
  updateNumbers();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER - MAIN STRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildStructure() {
  const sorted = [...S.tickers].sort((a, b) => {
    const sa = calcAll(a), sb = calcAll(b);
    return (sb?.comp || 0) - (sa?.comp || 0);
  });
  
  let html = '';
  
  // â”€â”€ HEADER â”€â”€
  html += `<div class="header">
    <div class="header-left">
      <div class="mono" style="font-size:9px;color:var(--blue);letter-spacing:2px;margin-bottom:3px">PROJECT ARES v10.1</div>
      <h1 class="mono">Entry Signal Engine</h1>
      <div class="status-row mono" id="status-row">
        <span class="dot ${S.wsConnected ? 'ws' : S.lastPoll ? 'live' : 'off'}" id="status-dot"></span>
        <span id="status-label">${S.wsConnected ? 'REAL-TIME (WS)' : S.lastPoll ? 'FINNHUB REST' : 'CONNECTING...'}</span>
        <span>â€¢</span>
        <span id="status-time">${S.lastPoll ? S.lastPoll.toLocaleTimeString() : 'â€”'}</span>
        <span id="status-ws">${S.wsLast ? 'â€¢ WS: ' + S.wsLast.toLocaleTimeString() : ''}</span>
        <span>â€¢ Next: <span id="countdown">${S.countdown}</span>s</span>
        <span style="color:var(--blue);cursor:pointer;text-decoration:underline" onclick="pollFinnhub()">â†» Now</span>
      </div>
    </div>
    <div>
      ${S.apiKey ? `<button class="btn btn-sm btn-outline mono" onclick="toggleApiSetup()">${S.wsConnected ? 'ğŸŸ¢ Connected' : 'âš¡ Reconnect'}</button>`
        : `<button class="btn btn-sm mono" onclick="toggleApiSetup()">âš¡ Add Finnhub Key</button>`}
    </div>
  </div>`;
  
  // â”€â”€ API SETUP â”€â”€
  html += `<div class="api-setup" id="api-setup">
    <h3 class="mono">ğŸ”‘ Finnhub API Key â€” Free Real-Time Data</h3>
    <p>Get <strong>real-time</strong> stock prices streamed via WebSocket (no delay).</p>
    <div class="steps"><strong>1.</strong> Go to <a href="https://finnhub.io" target="_blank" style="color:var(--blue)">finnhub.io</a> â†’ Sign up free<br>
      <strong>2.</strong> Copy your API key from the dashboard<br>
      <strong>3.</strong> Paste below â€” saved locally in your browser</div>
    <div class="api-input-row">
      <input id="api-key-input" type="text" placeholder="Paste Finnhub API key here..." value="${S.apiKey}">
      <button class="btn mono" onclick="saveApiKey()">Connect</button>
      ${S.apiKey ? `<button class="btn btn-sm btn-outline mono" onclick="clearApiKey()">Clear</button>` : ''}
    </div>
  </div>`;
  
  // â”€â”€ TABS â”€â”€
  html += `<div class="tabs">
    <div class="tab ${S.currentTab === 'signals' ? 'active' : ''}" onclick="switchTab('signals')">ğŸ“Š Signals</div>
    <div class="tab ${S.currentTab === 'trading' ? 'active' : ''}" onclick="switchTab('trading')">ğŸ’¼ Paper Trading</div>
    <div class="tab ${S.currentTab === 'performance' ? 'active' : ''}" onclick="switchTab('performance')">ğŸ“ˆ Performance</div>
  </div>`;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  TAB: SIGNALS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  html += `<div class="tab-content ${S.currentTab === 'signals' ? 'active' : ''}" id="tab-signals">`;
  
  // Search
  html += `<div class="search-container">
    <span class="search-icon">ğŸ”</span>
    <input type="text" class="search-input mono" id="search-input" placeholder="Search any stock (e.g. AAPL, TSLA, GOOGL)..." oninput="handleSearch(this.value)" onfocus="this.select()">
    <div class="search-results" id="search-results"></div>
  </div>`;
  
  // Market bar
  html += `<div class="market-row">
    <div class="market-chip"><div class="mono lbl">VIXY (VIX)</div><div class="mono val" id="mkt-vix">â€”</div><div class="mono chg" id="mkt-vix-chg">â€”</div></div>
    <div class="market-chip"><div class="mono lbl">SPY (S&P)</div><div class="mono val" id="mkt-sp">â€”</div><div class="mono chg" id="mkt-sp-chg">â€”</div></div>
    <div class="market-chip"><div class="mono lbl">QQQ (NDX)</div><div class="mono val" id="mkt-ndx">â€”</div><div class="mono chg" id="mkt-ndx-chg">â€”</div></div>
    <div class="market-chip"><div class="mono lbl">FEAR / GREED</div><div class="mono val" id="mkt-fg">â€”</div><div class="mono chg" id="mkt-fg-lbl" style="color:var(--text-3)">â€”</div></div>
  </div>`;
  
  // Phase banner
  html += `<div class="phase-banner" id="phase-banner" style="border-color:var(--text-3)30;background:transparent">
    <div><span class="mono" style="font-size:11px;color:var(--text-2)">OVERALL SIGNAL â†’</span>
      <span class="mono" style="font-size:15px;font-weight:800;margin-left:10px" id="phase-signal">â€”</span></div>
    <span class="mono" style="font-size:10px;color:var(--text-3)" id="phase-meta">â€”</span>
  </div>`;
  
  // Weights
  html += `<div class="weights-panel">
    <div class="mono" style="font-size:8px;color:var(--text-3);letter-spacing:1px;margin-bottom:8px">FACTOR WEIGHTS</div>
    <div class="weights-grid">
      ${['technical', 'value', 'catalyst', 'volatility', 'momentum'].map((k, i) => {
        const colors = ['var(--blue)', 'var(--purple)', 'var(--amber)', 'var(--red)', 'var(--green)'];
        const labels = ['TECHNICAL', 'VALUE', 'CATALYST', 'VOLATILITY', 'MOMENTUM'];
        return `<div class="weight-item">
          <label class="mono"><span style="color:${colors[i]}">${labels[i]}</span><span style="color:var(--text-0);font-weight:700" id="w-val-${k}">${S.weights[k]}%</span></label>
          <input type="range" min="5" max="55" value="${S.weights[k]}" id="w-slider-${k}" oninput="adjustWeight('${k}',parseInt(this.value))">
        </div>`;
      }).join('')}
    </div>
  </div>`;
  
  // Ticker cards
  html += `<div class="cards-grid" id="cards-grid">`;
  for (const t of sorted) {
    const m = getTickerMeta(t);
    const isSel = S.selected === t;
    const isDefault = DEFAULT_TICKERS.includes(t);
    const hasPosition = S.positions.some(p => p.ticker === t);
    
    html += `<div class="ticker-card ${isSel ? 'selected' : ''}" data-ticker="${t}" id="card-${t}" style="${isSel ? `border-color:${m.color}40` : ''}">
      <div class="accent" style="background:linear-gradient(90deg,${m.color},transparent)"></div>
      ${!isDefault ? `<button class="remove-btn mono" onclick="event.stopPropagation(); removeTicker('${t}')">Ã—</button>` : ''}
      <div class="top">
        <div><div class="mono sym">${t} <span style="font-size:7px;color:var(--blue)" id="ws-icon-${t}"></span></div><div class="nm">${m.name || t}</div></div>
        <div class="signal-badge mono" id="badge-${t}">â€”</div>
      </div>
      <div class="price-row">
        <span class="mono price live-num" id="price-${t}">â€”</span>
        <span class="mono day-chg live-num" id="chg-${t}">â€”</span>
      </div>
      <div id="spark-${t}" style="margin:-2px 0 6px;height:32px;opacity:0.7"></div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <span class="mono" style="font-size:8px" id="trend-${t}">â€”</span>
        <div class="meta-row mono" style="margin:0">
          <span>RSI <span id="rsi-${t}">â€”</span></span>
          <span>PEG ${(m.pegRatio || 1).toFixed(1)}</span>
          <span>E: <span id="dte-${t}">â€”</span></span>
        </div>
      </div>
      <div class="score-bar"><div class="bar-hdr mono"><span>TECH</span><span class="bv" id="ts-${t}">â€”</span></div><div class="bar-track"><div class="bar-fill" id="tb-${t}" style="width:0%;background:linear-gradient(90deg,var(--blue)80,var(--blue))"></div></div></div>
      <div class="score-bar"><div class="bar-hdr mono"><span>VALUE</span><span class="bv" id="vs-${t}">â€”</span></div><div class="bar-track"><div class="bar-fill" id="vb-${t}" style="width:0%;background:linear-gradient(90deg,var(--purple)80,var(--purple))"></div></div></div>
      <div class="score-bar"><div class="bar-hdr mono"><span>CAT</span><span class="bv" id="cs-${t}">â€”</span></div><div class="bar-track"><div class="bar-fill" id="cb-${t}" style="width:0%;background:linear-gradient(90deg,var(--amber)80,var(--amber))"></div></div></div>
      <div class="score-bar"><div class="bar-hdr mono"><span>VOL</span><span class="bv" id="vos-${t}">â€”</span></div><div class="bar-track"><div class="bar-fill" id="vob-${t}" style="width:0%;background:linear-gradient(90deg,var(--red)80,var(--red))"></div></div></div>
      <div class="score-bar"><div class="bar-hdr mono"><span style="color:var(--green)">MOM</span><span class="bv" id="ms-${t}">â€”</span></div><div class="bar-track"><div class="bar-fill" id="mb-${t}" style="width:0%;background:linear-gradient(90deg,var(--green)80,var(--green))"></div></div></div>
      <div class="composite-row"><span class="mono cl">COMPOSITE</span><span class="mono cv live-num" id="comp-${t}">â€”</span></div>
      <div class="actions">
        ${hasPosition 
          ? `<button class="btn btn-sm btn-amber mono" onclick="event.stopPropagation(); openCloseModal(${S.positions.find(p => p.ticker === t)?.id})">Close Position</button>`
          : `<button class="btn btn-sm btn-green mono" onclick="event.stopPropagation(); openBuyModal('${t}')">Paper Buy</button>`
        }
      </div>
    </div>`;
  }
  html += `</div>`;
  
  // Detail panel
  const sel = S.selected;
  const m = getTickerMeta(sel);
  html += `<div class="detail-panel" id="detail-panel">
    <div class="detail-header">
      <div class="detail-title">
        <div class="bar" style="background:${m.color}" id="detail-bar"></div>
        <div><h2 class="mono" id="detail-name">${sel} â€” ${m.name || sel}</h2>
          <div class="sub" id="detail-notes">${m.notes || 'Loading data...'}</div></div>
      </div>
      <div class="detail-signal mono" id="detail-signal">â€”</div>
    </div>
    <div class="metrics-grid" id="detail-metrics"></div>
    <div class="detail-cols">
      <div><div class="mono section-title">SCORE BREAKDOWN</div>
        <div class="score-bar"><div class="bar-hdr mono"><span id="d-tech-lbl">TECHNICAL</span><span class="bv" id="d-tech-val">â€”</span></div><div class="bar-track"><div class="bar-fill" id="d-tech-bar" style="width:0%;background:linear-gradient(90deg,var(--blue)80,var(--blue))"></div></div></div>
        <div class="score-bar"><div class="bar-hdr mono"><span id="d-val-lbl">VALUE</span><span class="bv" id="d-val-val">â€”</span></div><div class="bar-track"><div class="bar-fill" id="d-val-bar" style="width:0%;background:linear-gradient(90deg,var(--purple)80,var(--purple))"></div></div></div>
        <div class="score-bar"><div class="bar-hdr mono"><span id="d-cat-lbl">CATALYST</span><span class="bv" id="d-cat-val">â€”</span></div><div class="bar-track"><div class="bar-fill" id="d-cat-bar" style="width:0%;background:linear-gradient(90deg,var(--amber)80,var(--amber))"></div></div></div>
        <div class="score-bar"><div class="bar-hdr mono"><span id="d-vol-lbl">VOLATILITY</span><span class="bv" id="d-vol-val">â€”</span></div><div class="bar-track"><div class="bar-fill" id="d-vol-bar" style="width:0%;background:linear-gradient(90deg,var(--red)80,var(--red))"></div></div></div>
        <div class="score-bar"><div class="bar-hdr mono"><span id="d-mom-lbl" style="color:var(--green)">MOMENTUM</span><span class="bv" id="d-mom-val">â€”</span></div><div class="bar-track"><div class="bar-fill" id="d-mom-bar" style="width:0%;background:linear-gradient(90deg,var(--green)80,var(--green))"></div></div></div>
        <div style="margin-top:8px;padding:6px 10px;background:var(--bg-1);border-radius:6px;border:1px solid #141824;display:flex;justify-content:space-between;align-items:center">
          <span class="mono" style="font-size:8px;color:var(--text-3)">TREND REGIME</span>
          <span class="mono" style="font-size:11px;font-weight:700" id="d-trend">â€”</span>
        </div>
        <div style="margin-top:4px;font-size:8px;color:var(--text-3)" id="d-trend-note"></div>
      </div>
      <div><div class="mono section-title">DECISION FACTORS</div>
        <div class="factors" id="d-factors">â€”</div></div>
    </div>
  </div>`;
  
  html += `</div>`; // end tab-signals
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  TAB: PAPER TRADING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  html += `<div class="tab-content ${S.currentTab === 'trading' ? 'active' : ''}" id="tab-trading">`;
  
  // Auto trade controls
  const stratSummary = Object.entries(STRATEGIES).map(([k, s]) => 
    `<span style="color:var(--text-1)">${s.name}</span> ${Math.round(s.alloc*100)}% Â· ${s.hold}d hold Â· ${Math.round(s.tpPct*100)}% TP`
  ).join(' &nbsp;â”‚&nbsp; ');
  
  html += `<div class="detail-panel" style="margin-bottom:14px;padding:14px 18px">
    <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px">
      <div style="display:flex;align-items:center;gap:12px">
        <span class="mono" style="font-size:12px;color:var(--text-2)">ğŸ¤– AUTO TRADING â€” 3 STRATEGIES COMBINED</span>
        <button class="btn btn-sm mono ${S.autoTradeEnabled ? 'btn-green' : 'btn-outline'}" onclick="toggleAutoTrade()">
          ${S.autoTradeEnabled ? 'â— ENABLED' : 'â—‹ DISABLED'}
        </button>
      </div>
      <div style="display:flex;gap:6px">
        ${Object.entries(STRATEGIES).map(([key, s]) => `
          <span class="mono" style="font-size:10px;padding:4px 10px;border-radius:4px;background:var(--bg-3);color:var(--text-1)">
            ${s.name} ${Math.round(s.alloc * 100)}%
          </span>
        `).join('')}
      </div>
    </div>
    <div class="mono" style="font-size:9px;color:var(--text-3);margin-top:8px">
      ${S.autoTradeEnabled 
        ? stratSummary + ' &nbsp;â”‚&nbsp; Min 6/9 confluence &nbsp;â”‚&nbsp; Same signal â†’ 3 positions (different exit rules)'
        : 'Enable to auto-run all 3 strategies simultaneously with independent entry/exit management'}
    </div>
  </div>`;
  
  // Portfolio summary
  const portfolioValue = calculatePortfolioValue();
  const totalPnL = portfolioValue - S.portfolio.startingCapital;
  const totalPnLPercent = (totalPnL / S.portfolio.startingCapital * 100);
  const winningTrades = S.tradeHistory.filter(t => t.pnl > 0).length;
  const totalTrades = S.tradeHistory.length;
  const winRate = totalTrades > 0 ? (winningTrades / totalTrades * 100) : 0;
  
  html += `<div class="portfolio-summary">
    <div class="portfolio-card">
      <div class="label mono">STARTING CAPITAL</div>
      <div class="value mono">$${S.portfolio.startingCapital.toLocaleString()}</div>
    </div>
    <div class="portfolio-card">
      <div class="label mono">CURRENT VALUE</div>
      <div class="value mono" style="color:${portfolioValue >= S.portfolio.startingCapital ? 'var(--green)' : 'var(--red)'}">$${portfolioValue.toLocaleString(undefined, { maximumFractionDigits: 2 })}</div>
    </div>
    <div class="portfolio-card">
      <div class="label mono">CASH</div>
      <div class="value mono">$${S.portfolio.cash.toLocaleString(undefined, { maximumFractionDigits: 2 })}</div>
    </div>
    <div class="portfolio-card">
      <div class="label mono">TOTAL P&L</div>
      <div class="value mono" style="color:${totalPnL >= 0 ? 'var(--green)' : 'var(--red)'}">${totalPnL >= 0 ? '+' : ''}$${totalPnL.toFixed(2)}</div>
      <div class="sub mono">${totalPnLPercent >= 0 ? '+' : ''}${totalPnLPercent.toFixed(2)}%</div>
    </div>
    <div class="portfolio-card">
      <div class="label mono">WIN RATE</div>
      <div class="value mono" style="color:${winRate >= 50 ? 'var(--green)' : 'var(--amber)'}">${winRate.toFixed(1)}%</div>
      <div class="sub mono">${winningTrades}/${totalTrades} trades</div>
    </div>
  </div>`;
  
  // Open positions
  html += `<div class="detail-panel">
    <h3 class="mono" style="font-size:12px;color:var(--text-2);margin-bottom:12px">ğŸ“Š OPEN POSITIONS</h3>`;
  
  if (S.positions.length === 0) {
    html += `<div class="empty-state">
      <div class="icon">ğŸ“­</div>
      <h4>No Open Positions</h4>
      <p>Use the "Paper Buy" button on any stock card to open a position</p>
    </div>`;
  } else {
    html += `<table class="positions-table">
      <thead><tr>
        <th class="mono">TICKER</th>
        <th class="mono">SHARES</th>
        <th class="mono">ENTRY</th>
        <th class="mono">CURRENT</th>
        <th class="mono">P&L</th>
        <th class="mono">STOP / TRAIL</th>
        <th class="mono">TP</th>
        <th class="mono">STRATEGY</th>
        <th class="mono">ACTION</th>
      </tr></thead>
      <tbody>`;
    
    for (const pos of S.positions) {
      const price = S.prices[pos.ticker]?.price || pos.entryPrice;
      const pnl = (price - pos.entryPrice) * pos.shares;
      const pnlPercent = ((price - pos.entryPrice) / pos.entryPrice * 100);
      const activeStop = pos.trailStop || pos.stopLoss;
      const daysHeld = Math.round((new Date() - new Date(pos.entryDate)) / 86400000);
      const maxDays = pos.maxExitDate ? Math.round((new Date(pos.maxExitDate) - new Date(pos.entryDate)) / 86400000) : 'â€”';
      
      html += `<tr>
        <td class="mono" style="font-weight:700">${pos.ticker}<br><span style="font-size:8px;color:var(--text-3)">${pos.confluenceVotes || '?'}/9 conf</span></td>
        <td class="mono">${pos.shares}</td>
        <td class="mono">$${pos.entryPrice.toFixed(2)}</td>
        <td class="mono">$${price.toFixed(2)}</td>
        <td class="mono" style="color:${pnl >= 0 ? 'var(--green)' : 'var(--red)'}">${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}<br><span style="font-size:10px">${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%</span></td>
        <td class="mono" style="font-size:10px">${activeStop ? '$' + activeStop.toFixed(2) : 'â€”'}${pos.trailStop ? ' ğŸ”„' : ''}</td>
        <td class="mono" style="font-size:10px">${pos.takeProfit ? '$' + pos.takeProfit.toFixed(2) : 'â€”'}</td>
        <td class="mono" style="font-size:10px">${pos.strategy || 'manual'}<br><span style="color:var(--text-3)">${daysHeld}d / ${maxDays}d</span></td>
        <td><button class="btn btn-sm btn-red" onclick="openCloseModal(${pos.id})">Close</button></td>
      </tr>`;
    }
    
    html += `</tbody></table>`;
  }
  html += `</div>`;
  
  // Trade history
  html += `<div class="detail-panel">
    <h3 class="mono" style="font-size:12px;color:var(--text-2);margin-bottom:12px">ğŸ“œ TRADE HISTORY</h3>`;
  
  if (S.tradeHistory.length === 0) {
    html += `<div class="empty-state">
      <div class="icon">ğŸ“‹</div>
      <h4>No Trade History</h4>
      <p>Closed positions will appear here</p>
    </div>`;
  } else {
    html += `<table class="trades-table">
      <thead><tr>
        <th class="mono">DATE</th>
        <th class="mono">TICKER</th>
        <th class="mono">SHARES</th>
        <th class="mono">ENTRY</th>
        <th class="mono">EXIT</th>
        <th class="mono">P&L</th>
        <th class="mono">EXIT REASON</th>
      </tr></thead>
      <tbody>`;
    
    for (const trade of S.tradeHistory.slice(0, 20)) {
      const exitColor = trade.exitReason === 'TAKE PROFIT' ? 'var(--green)' : trade.exitReason === 'STOP LOSS' ? 'var(--red)' : 'var(--text-2)';
      html += `<tr>
        <td class="mono" style="font-size:10px">${new Date(trade.exitDate).toLocaleDateString()}</td>
        <td class="mono" style="font-weight:700">${trade.ticker}</td>
        <td class="mono">${trade.shares}</td>
        <td class="mono">$${trade.entryPrice.toFixed(2)}</td>
        <td class="mono">$${trade.exitPrice.toFixed(2)}</td>
        <td class="mono" style="color:${trade.pnl >= 0 ? 'var(--green)' : 'var(--red)'}">${trade.pnl >= 0 ? '+' : ''}$${trade.pnl.toFixed(2)} (${trade.pnlPercent >= 0 ? '+' : ''}${trade.pnlPercent.toFixed(2)}%)</td>
        <td class="mono" style="font-size:10px;color:${exitColor}">${trade.exitReason || trade.signalAtEntry}</td>
      </tr>`;
    }
    
    html += `</tbody></table>`;
  }
  html += `</div>`;
  
  html += `</div>`; // end tab-trading
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  TAB: PERFORMANCE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  html += `<div class="tab-content ${S.currentTab === 'performance' ? 'active' : ''}" id="tab-performance">`;
  
  // Portfolio chart
  html += `<div class="chart-container">
    <h3 class="mono">PORTFOLIO VALUE OVER TIME</h3>
    <svg class="chart-svg" id="portfolio-chart" viewBox="0 0 800 200">
      <defs>
        <linearGradient id="chartGradient" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" style="stop-color:var(--blue);stop-opacity:0.3" />
          <stop offset="100%" style="stop-color:var(--blue);stop-opacity:0" />
        </linearGradient>
      </defs>
      ${renderPortfolioChart()}
    </svg>
  </div>`;
  
  // Stats grid
  const avgReturn = totalTrades > 0 ? S.tradeHistory.reduce((a, t) => a + t.pnlPercent, 0) / totalTrades : 0;
  const bestTrade = S.tradeHistory.length > 0 ? Math.max(...S.tradeHistory.map(t => t.pnl)) : 0;
  const worstTrade = S.tradeHistory.length > 0 ? Math.min(...S.tradeHistory.map(t => t.pnl)) : 0;
  
  html += `<div class="stats-grid">
    <div class="stat-card">
      <div class="label mono">TOTAL TRADES</div>
      <div class="value mono">${totalTrades}</div>
    </div>
    <div class="stat-card">
      <div class="label mono">AVG RETURN</div>
      <div class="value mono" style="color:${avgReturn >= 0 ? 'var(--green)' : 'var(--red)'}">${avgReturn >= 0 ? '+' : ''}${avgReturn.toFixed(2)}%</div>
    </div>
    <div class="stat-card">
      <div class="label mono">BEST TRADE</div>
      <div class="value mono" style="color:var(--green)">${bestTrade >= 0 ? '+' : ''}$${bestTrade.toFixed(2)}</div>
    </div>
    <div class="stat-card">
      <div class="label mono">WORST TRADE</div>
      <div class="value mono" style="color:var(--red)">${worstTrade >= 0 ? '+' : ''}$${worstTrade.toFixed(2)}</div>
    </div>
  </div>`;
  
  // Signal accuracy
  html += `<div class="accuracy-section">
    <h3 class="mono">SIGNAL ACCURACY â€” When model said BUY/STRONG BUY, did price go up?</h3>
    <div class="accuracy-bars">
      ${renderAccuracyBar('1 Day', calculateSignalAccuracy(1))}
      ${renderAccuracyBar('7 Days', calculateSignalAccuracy(7))}
      ${renderAccuracyBar('30 Days', calculateSignalAccuracy(30))}
    </div>
  </div>`;
  
  // Factor analysis
  html += `<div class="accuracy-section">
    <h3 class="mono">FACTOR CORRELATION WITH WINS</h3>
    <div class="accuracy-bars">
      ${renderFactorCorrelation()}
    </div>
  </div>`;
  
  html += `</div>`; // end tab-performance
  
  // â”€â”€ FOOTER â”€â”€
  html += `<div class="footer mono">
    <span style="color:var(--blue);font-weight:700;letter-spacing:1px">MODEL v10.1</span> â€¢
    ${S.wsConnected ? 'Real-time via Finnhub WebSocket' : 'Finnhub REST polling'} â€¢
    Live RSI(14) â€¢ Live Fear/Greed Index â€¢ Paper Trading â€¢ Supabase Integration<br>
    <strong>TECH</strong>: RSI(14), SMA50, SMA200, support/resistance â€¢
    <strong>VALUE</strong>: ATH drawdown, PEG, analyst targets â€¢
    <strong>CATALYST</strong>: Earnings proximity â€¢
    <strong>VOL</strong>: VIX, IV, Fear/Greed<br>
    <strong>SIGNALS</strong>: STRONG BUY (75+) â†’ BUY (60+) â†’ ACCUMULATE (45+) â†’ WAIT (30+) â†’ AVOID (&lt;30)
    <div class="warn">âš  Decision-support tool only. Not financial advice. Paper trading only.</div>
  </div>`;
  
  document.getElementById('app').innerHTML = html;
  
  // Attach card click listeners
  document.querySelectorAll('.ticker-card').forEach(c => {
    c.onclick = (e) => {
      if (e.target.tagName === 'BUTTON') return;
      S.prevSelected = S.selected;
      S.selected = c.dataset.ticker;
      buildStructure();
      updateNumbers();
    };
  });
  
  // Close search on click outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.search-container')) {
      hideSearch();
    }
  });
  
  S.structureBuilt = true;
}

function renderPortfolioChart() {
  if (S.portfolioHistory.length < 2) {
    // Generate sample data from trades
    const history = [{ date: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), value: S.portfolio.startingCapital }];
    let value = S.portfolio.startingCapital;
    
    for (const trade of [...S.tradeHistory].reverse()) {
      value += trade.pnl;
      history.push({ date: new Date(trade.exitDate), value });
    }
    
    history.push({ date: new Date(), value: calculatePortfolioValue() });
    S.portfolioHistory = history;
  }
  
  if (S.portfolioHistory.length < 2) {
    return `<text x="400" y="100" text-anchor="middle" class="chart-label" style="font-size:14px">No data yet â€” start trading!</text>`;
  }
  
  const data = S.portfolioHistory;
  const minVal = Math.min(...data.map(d => d.value)) * 0.95;
  const maxVal = Math.max(...data.map(d => d.value)) * 1.05;
  const range = maxVal - minVal || 1;
  
  const points = data.map((d, i) => {
    const x = (i / (data.length - 1)) * 760 + 20;
    const y = 180 - ((d.value - minVal) / range) * 160;
    return `${x},${y}`;
  }).join(' ');
  
  const areaPoints = points + ` 780,180 20,180`;
  
  return `
    <polyline class="chart-line" points="${points}" />
    <polygon class="chart-area" points="${areaPoints}" />
    <text x="20" y="20" class="chart-label">$${maxVal.toFixed(0)}</text>
    <text x="20" y="190" class="chart-label">$${minVal.toFixed(0)}</text>
  `;
}

function renderAccuracyBar(label, accuracy) {
  const pct = accuracy || 0;
  const cls = pct >= 60 ? 'good' : pct >= 40 ? 'mid' : 'bad';
  return `<div class="accuracy-bar">
    <span class="label mono">${label}</span>
    <div class="track"><div class="fill ${cls}" style="width:${pct}%">${pct.toFixed(0)}%</div></div>
  </div>`;
}

function calculateSignalAccuracy(days) {
  // This would normally compare snapshots â€” simplified for now
  const buySignals = S.tradeHistory.filter(t => t.signalAtEntry === 'BUY' || t.signalAtEntry === 'STRONG BUY');
  if (buySignals.length === 0) return 50; // neutral
  const winning = buySignals.filter(t => t.pnl > 0).length;
  return (winning / buySignals.length) * 100;
}

function renderFactorCorrelation() {
  // Analyze which factor correlated with wins
  const factors = ['TECHNICAL', 'VALUE', 'CATALYST', 'VOLATILITY'];
  // Simplified â€” would need signal snapshots for real analysis
  return factors.map((f, i) => {
    const corr = 40 + Math.random() * 40; // placeholder
    const cls = corr >= 60 ? 'good' : corr >= 40 ? 'mid' : 'bad';
    return `<div class="accuracy-bar">
      <span class="label mono">${f}</span>
      <div class="track"><div class="fill ${cls}" style="width:${corr}%">${corr.toFixed(0)}%</div></div>
    </div>`;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UPDATE NUMBERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderSparkline(containerId, data, color) {
  const el = document.getElementById(containerId);
  if (!el || !data || data.length < 2) return;
  const w = el.offsetWidth || 180, h = 32;
  const min = Math.min(...data), max = Math.max(...data);
  const range = max - min || 1;
  const points = data.map((v, i) => `${(i / (data.length - 1)) * w},${h - ((v - min) / range) * (h - 4) - 2}`).join(' ');
  const lastY = h - ((data[data.length - 1] - min) / range) * (h - 4) - 2;
  // Gradient fill under the line
  const fillPoints = `0,${h} ${points} ${w},${h}`;
  el.innerHTML = `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
    <defs><linearGradient id="sg-${containerId}" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="${color}" stop-opacity="0.15"/>
      <stop offset="100%" stop-color="${color}" stop-opacity="0"/>
    </linearGradient></defs>
    <polygon points="${fillPoints}" fill="url(#sg-${containerId})"/>
    <polyline points="${points}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    <circle cx="${w}" cy="${lastY}" r="2" fill="${color}"/>
  </svg>`;
}

function updateNumbers() {
  if (!S.structureBuilt) return;
  
  let sumComp = 0, n = 0;
  
  for (const t of S.tickers) {
    const sc = calcAll(t);
    const p = S.prices[t];
    if (!sc || !p?.price) continue;
    
    const m = getTickerMeta(t);
    const s = sig(sc.comp);
    const prev = S.prevSnapshot[t] || p.price;
    const dayChg = p.prevClose ? ((p.price - p.prevClose) / p.prevClose * 100) : 0;
    const dayPos = dayChg >= 0;
    const dd = m.ath > 0 ? ((m.ath - p.price) / m.ath * 100).toFixed(1) : 'â€”';
    const tickDir = p.price > prev ? 'up' : p.price < prev ? 'dn' : '';
    
    // Update card numbers
    const priceEl = document.getElementById(`price-${t}`);
    if (priceEl) {
      const newText = '$' + p.price.toFixed(2);
      if (priceEl.textContent !== newText) {
        priceEl.textContent = newText;
        if (tickDir) {
          priceEl.classList.remove('tick-up', 'tick-dn');
          priceEl.classList.add(tickDir === 'up' ? 'tick-up' : 'tick-dn');
          setTimeout(() => priceEl.classList.remove('tick-up', 'tick-dn'), 800);
        }
      }
    }
    
    setText(`chg-${t}`, (dayPos ? '+' : '') + dayChg.toFixed(2) + '%');
    setColor(`chg-${t}`, dayPos ? 'var(--green-bright)' : 'var(--red-bright)');
    setText(`dd-${t}`, dd !== 'â€”' ? '-' + dd + '%' : 'â€”');
    setText(`rsi-${t}`, (m._live?.rsi != null ? '' : '~') + sc.rsi.toFixed(1));
    setText(`dte-${t}`, sc.dte != null ? sc.dte + 'd' : 'â€”');
    
    setText(`ts-${t}`, sc.tech.toFixed(0)); setBar(`tb-${t}`, sc.tech);
    setText(`vs-${t}`, sc.val.toFixed(0)); setBar(`vb-${t}`, sc.val);
    setText(`cs-${t}`, sc.cat.toFixed(0)); setBar(`cb-${t}`, sc.cat);
    setText(`vos-${t}`, sc.vol.toFixed(0)); setBar(`vob-${t}`, sc.vol);
    setText(`ms-${t}`, sc.mom.toFixed(0)); setBar(`mb-${t}`, sc.mom);
    
    // Trend indicator
    const trendEl = document.getElementById(`trend-${t}`);
    if (trendEl) { trendEl.textContent = sc.trend.label; }
    
    // Sparkline (render once, not every tick)
    if (m.sparkData?.length > 2 && !document.querySelector(`#spark-${t} svg`)) {
      const sparkColor = dayPos ? 'var(--green-bright)' : 'var(--red-bright)';
      renderSparkline(`spark-${t}`, m.sparkData, sparkColor);
    }
    
    const compEl = document.getElementById(`comp-${t}`);
    if (compEl) { compEl.textContent = sc.comp.toFixed(0); compEl.style.color = s.color; }
    
    const badge = document.getElementById(`badge-${t}`);
    if (badge) { badge.textContent = s.label; badge.style.background = s.bg; badge.style.color = s.color; badge.style.border = `1px solid ${s.color}25`; }
    
    const wsIcon = document.getElementById(`ws-icon-${t}`);
    if (wsIcon) wsIcon.textContent = p.source === 'finnhub-ws' ? 'âš¡' : '';
    
    sumComp += sc.comp; n++;
  }
  
  // Market
  setText('mkt-vix', (S.market.vix || 0).toFixed(2));
  const vChg = S.market.vixPrev ? ((S.market.vix - S.market.vixPrev) / S.market.vixPrev * 100).toFixed(2) : 'â€”';
  setText('mkt-vix-chg', (parseFloat(vChg) >= 0 ? '+' : '') + vChg + '%');
  setColor('mkt-vix-chg', parseFloat(vChg) > 0 ? 'var(--red-bright)' : 'var(--green-bright)');
  
  setText('mkt-sp', (S.market.sp500 || 0).toLocaleString(undefined, { maximumFractionDigits: 0 }));
  const sChg = S.market.sp500Prev ? ((S.market.sp500 - S.market.sp500Prev) / S.market.sp500Prev * 100).toFixed(2) : 'â€”';
  setText('mkt-sp-chg', (parseFloat(sChg) >= 0 ? '+' : '') + sChg + '%');
  setColor('mkt-sp-chg', parseFloat(sChg) >= 0 ? 'var(--green-bright)' : 'var(--red-bright)');
  
  setText('mkt-ndx', (S.market.ndx || 0).toLocaleString(undefined, { maximumFractionDigits: 0 }));
  const nChg = S.market.ndxPrev ? ((S.market.ndx - S.market.ndxPrev) / S.market.ndxPrev * 100).toFixed(2) : 'â€”';
  setText('mkt-ndx-chg', (parseFloat(nChg) >= 0 ? '+' : '') + nChg + '%');
  setColor('mkt-ndx-chg', parseFloat(nChg) >= 0 ? 'var(--green-bright)' : 'var(--red-bright)');
  
  const fg = S.market.fearGreed;
  setText('mkt-fg', fg);
  setColor('mkt-fg', fg < 30 ? 'var(--red)' : fg < 50 ? 'var(--orange)' : 'var(--green)');
  setText('mkt-fg-lbl', fg < 25 ? 'EXTREME FEAR' : fg < 40 ? 'FEAR' : fg < 60 ? 'NEUTRAL' : 'GREED');
  
  // Phase banner
  const avgComp = n > 0 ? sumComp / n : 0;
  const os = sig(avgComp);
  const pb = document.getElementById('phase-banner');
  if (pb) { pb.style.borderColor = os.color + '30'; pb.style.background = os.bg; }
  const ps = document.getElementById('phase-signal');
  if (ps) { ps.textContent = os.label; ps.style.color = os.color; }
  setText('phase-meta', `AVG: ${avgComp.toFixed(0)} | Refresh #${S.refreshCount} | ${S.tickers.length} tickers`);
  
  updateDetailNumbers();
}

function updateDetailNumbers() {
  const t = S.selected;
  const sc = calcAll(t);
  const p = S.prices[t];
  const m = getTickerMeta(t);
  if (!sc || !p?.price) return;
  
  const s = sig(sc.comp);
  const dd = m.ath > 0 ? ((m.ath - p.price) / m.ath * 100).toFixed(1) : 'â€”';
  const up = m.analystTarget > 0 ? ((m.analystTarget - p.price) / p.price * 100).toFixed(1) : 'â€”';
  const dayChg = p.prevClose ? ((p.price - p.prevClose) / p.prevClose * 100).toFixed(2) : 'â€”';
  
  const ds = document.getElementById('detail-signal');
  if (ds) { ds.textContent = sc.comp.toFixed(0) + ' â€” ' + s.label; ds.style.background = s.bg; ds.style.color = s.color; ds.style.border = `1px solid ${s.color}25`; }
  setText('detail-name', t + ' â€” ' + (m.name || t));
  setText('detail-notes', m.notes || (m.sector ? `Sector: ${m.sector}` : 'Dynamic scoring from live data'));
  const bar = document.getElementById('detail-bar');
  if (bar) bar.style.background = m.color;
  
  const metrics = [
    { l: 'Price', v: `$${p.price?.toFixed(2)}` },
    { l: 'Day Chg', v: `${parseFloat(dayChg) >= 0 ? '+' : ''}${dayChg}%`, w: parseFloat(dayChg) < -3 },
    { l: 'Day Range', v: p.high ? `$${p.low?.toFixed(2)}â€“$${p.high?.toFixed(2)}` : 'â€”' },
    { l: 'ATH', v: m.ath > 0 ? `$${m.ath.toFixed(2)} (âˆ’${dd}%)` : 'â€”' },
    { l: m._live?.rsi != null ? 'RSI(14)' : 'RSI(est)', v: `${m._live?.rsi != null ? '' : '~'}${sc.rsi.toFixed(1)}`, w: sc.rsi < 35 },
    { l: 'SMA50', v: m.sma50 > 0 ? `$${m.sma50.toFixed(2)}` : 'â€”', w: p.price < m.sma50 },
    { l: 'Beta', v: (m.beta || 1).toFixed(2) },
    { l: 'Fwd P/E', v: m.forwardPe || 'â€”' },
    { l: 'PEG', v: m.pegRatio?.toFixed(2) || 'â€”', w: m.pegRatio < 0.5 },
    { l: 'Target', v: m.analystTarget > 0 ? `$${m.analystTarget.toFixed(2)} (+${up}%)` : 'â€”' },
    { l: 'Analysts', v: `${m.analystBuy || 0} Buy / ${m.analystSell || 0} Sell` },
    { l: 'Earnings', v: sc.dte != null ? `${sc.dte}d` : 'â€”', w: sc.dte >= 10 && sc.dte <= 25 },
    { l: 'P/C Ratio', v: m._live?.pcRatio != null ? m._live.pcRatio.toFixed(2) : 'â€”', w: m._live?.pcRatio > 1.2 },
    { l: 'Call OI', v: m._live?.callOI != null ? m._live.callOI.toLocaleString() : 'â€”' },
    { l: 'Put OI', v: m._live?.putOI != null ? m._live.putOI.toLocaleString() : 'â€”' },
    { l: 'SMA20', v: m.sma20 > 0 ? `$${m.sma20.toFixed(2)}` : 'â€”', w: p.price < m.sma20 },
    { l: 'SMA200', v: m.sma200 > 0 ? `$${m.sma200.toFixed(2)}` : 'â€”', w: p.price < m.sma200 },
    { l: 'ROC 5d', v: m.roc5 ? `${m.roc5 >= 0 ? '+' : ''}${m.roc5.toFixed(2)}%` : 'â€”', w: m.roc5 < -5 },
    { l: 'ROC 20d', v: m.roc20 ? `${m.roc20 >= 0 ? '+' : ''}${m.roc20.toFixed(2)}%` : 'â€”', w: m.roc20 < -10 },
    { l: 'Trend', v: sc.trend.label },
    { l: 'Vol Ratio', v: m._live?.volumeRatio ? `${m._live.volumeRatio.toFixed(2)}x avg` : 'â€”', w: m._live?.volumeRatio > 2 },
    { l: 'Avg Vol 20d', v: m._live?.avgVolume20 ? (m._live.avgVolume20 / 1e6).toFixed(1) + 'M' : 'â€”' },
    { l: 'News Sent.', v: m._live?.newsSentiment ? `${m._live.newsSentiment} (${m._live.newsSentiment > 55 ? 'Bullish' : m._live.newsSentiment < 45 ? 'Bearish' : 'Neutral'})` : 'â€”', w: m._live?.newsSentiment < 40 },
    { l: 'Source', v: p.source === 'finnhub-ws' ? 'âš¡ Real-time' : 'ğŸ“Š REST' },
  ];
  
  const mg = document.getElementById('detail-metrics');
  if (mg) mg.innerHTML = metrics.map(mt => `<div class="metric-box">
    <div class="mono ml">${mt.l}</div>
    <div class="mono mv ${mt.w ? 'warn' : ''}">${mt.v}</div>
  </div>`).join('');
  
  setText('d-tech-lbl', `TECHNICAL (Ã—${S.weights.technical}%)`);
  setText('d-tech-val', sc.tech.toFixed(0)); setBar('d-tech-bar', sc.tech);
  setText('d-val-lbl', `VALUE (Ã—${S.weights.value}%)`);
  setText('d-val-val', sc.val.toFixed(0)); setBar('d-val-bar', sc.val);
  setText('d-cat-lbl', `CATALYST (Ã—${S.weights.catalyst}%)`);
  setText('d-cat-val', sc.cat.toFixed(0)); setBar('d-cat-bar', sc.cat);
  setText('d-vol-lbl', `VOLATILITY (Ã—${S.weights.volatility}%)`);
  setText('d-vol-val', sc.vol.toFixed(0)); setBar('d-vol-bar', sc.vol);
  setText('d-mom-lbl', `MOMENTUM (Ã—${S.weights.momentum || 0}%)`);
  setText('d-mom-val', sc.mom.toFixed(0)); setBar('d-mom-bar', sc.mom);
  
  // Trend regime
  setText('d-trend', `${sc.trend.label} (cap: ${sc.trend.cap})`);
  const trendNote = sc.rawComp > sc.trend.cap 
    ? `âš ï¸ Raw score ${sc.rawComp.toFixed(0)} capped to ${sc.trend.cap} by trend filter â€” price is in ${sc.trend.regime}`
    : `Score within trend cap. Raw: ${sc.rawComp.toFixed(0)}`;
  setText('d-trend-note', trendNote);
  
  let factors = [];
  // Trend factor (most important â€” show first)
  if (sc.trend.regime === 'downtrend') factors.push('ğŸ”´ DOWNTREND â€” below SMA50 & SMA200. Score capped at 45. Wait for recovery.');
  else if (sc.trend.regime === 'pullback') factors.push('ğŸŸ¡ Pullback in uptrend â€” below SMA50 but above SMA200. Could be entry if other factors align.');
  else if (sc.trend.regime === 'recovery') factors.push('ğŸ”µ Recovery attempt â€” above SMA50 but below SMA200. Watch for confirmation.');
  else if (sc.trend.regime === 'bounce') factors.push('âš¡ Short-term bounce in downtrend â€” risky, trade small.');
  else factors.push('ğŸŸ¢ Uptrend â€” price above both SMAs. Best environment for entries.');
  
  if (sc.tech >= 60) factors.push('âœ… Technically oversold â€” good entry zone');
  else if (sc.tech >= 40) factors.push('â¡ï¸ Technicals moderate');
  else factors.push('âš ï¸ Could fall further');
  if (sc.val >= 60) factors.push('âœ… Strong fundamental value');
  else if (sc.val < 40) factors.push('âš ï¸ Valuation still elevated');
  if (sc.mom >= 60) factors.push('âœ… Strong momentum â€” trend is your friend');
  else if (sc.mom >= 40) factors.push('â¡ï¸ Moderate momentum');
  else factors.push('âš ï¸ Weak momentum â€” no follow-through');
  if (sc.cat >= 60) factors.push('âœ… Catalyst approaching');
  else if (sc.cat < 40) factors.push('âš ï¸ No near-term catalyst');
  if (sc.vol >= 50) factors.push('âœ… Elevated fear â€” good for entries');
  else if (sc.vol < 30) factors.push('âš ï¸ Low fear â€” may not have bottomed');
  if (sc.dte != null && sc.dte >= 10 && sc.dte <= 25) factors.push('ğŸ¯ Pre-earnings sweet spot');
  if (sc.rsi <= 30) factors.push('ğŸ”¥ RSI deeply oversold');
  if (dd !== 'â€”' && parseFloat(dd) > 20) factors.push(`ğŸ’° ${dd}% off ATH`);
  const fEl = document.getElementById('d-factors');
  if (fEl) fEl.innerHTML = factors.map(f => `<div>${f}</div>`).join('');
}

function updateStatus() {
  const dot = document.getElementById('status-dot');
  if (dot) { dot.className = 'dot ' + (S.wsConnected ? 'ws' : S.lastPoll ? 'live' : 'off'); }
  const lbl = document.getElementById('status-label');
  if (lbl) lbl.textContent = S.wsConnected ? 'REAL-TIME (WS)' : S.lastPoll ? 'FINNHUB REST' : 'CONNECTING...';
}

// â”€â”€ DOM helpers â”€â”€
function setText(id, text) {
  const el = document.getElementById(id);
  if (el && el.textContent != text) el.textContent = text;
}
function setColor(id, color) {
  const el = document.getElementById(id);
  if (el) el.style.color = color;
}
function setBar(id, val) {
  const el = document.getElementById(id);
  if (el) el.style.width = Math.min(val, 100) + '%';
}

// â”€â”€ Tab switching â”€â”€
function switchTab(tab) {
  S.currentTab = tab;
  history.pushState(null, '', '/' + (tab === 'signals' ? '' : tab));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
  document.querySelector(`.tab:nth-child(${tab === 'signals' ? 1 : tab === 'trading' ? 2 : 3})`).classList.add('active');
  document.getElementById(`tab-${tab}`).classList.add('active');
}
window.addEventListener('popstate', () => {
  const p = window.location.pathname.replace(/^\/+/,'').split('/')[0];
  const tab = ['signals','trading','performance'].includes(p) ? p : 'signals';
  S.currentTab = tab;
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
  document.querySelector(`.tab:nth-child(${tab === 'signals' ? 1 : tab === 'trading' ? 2 : 3})`).classList.add('active');
  document.getElementById(`tab-${tab}`).classList.add('active');
});

// â”€â”€ Search â”€â”€
function handleSearch(query) {
  clearTimeout(searchDebounce);
  searchDebounce = setTimeout(() => searchTickers(query), 300);
}

// â”€â”€ API key â”€â”€
function toggleApiSetup() {
  const el = document.getElementById('api-setup');
  el.classList.toggle('show');
}
function saveApiKey() {
  const key = document.getElementById('api-key-input').value.trim();
  if (!key) return;
  S.apiKey = key;
  localStorage.setItem('finnhub_key', key);
  connectWS();
  document.getElementById('api-setup').classList.remove('show');
  buildStructure();
}
function clearApiKey() {
  S.apiKey = '';
  localStorage.removeItem('finnhub_key');
  if (ws) { ws.close(); ws = null; }
  S.wsConnected = false;
  S.mode = 'polling';
  buildStructure();
  updateNumbers();
}

// Global functions
window.toggleApiSetup = toggleApiSetup;
window.saveApiKey = saveApiKey;
window.clearApiKey = clearApiKey;
window.pollFinnhub = pollFinnhub;
window.adjustWeight = adjustWeight;
window.switchTab = switchTab;
window.handleSearch = handleSearch;
window.addTicker = addTicker;
window.removeTicker = removeTicker;
window.hideSearch = hideSearch;
window.toggleAutoTrade = toggleAutoTrade;
window.openBuyModal = openBuyModal;
window.closeBuyModal = closeBuyModal;
window.executeBuy = executeBuy;
window.openCloseModal = openCloseModal;
window.closeCloseModal = closeCloseModal;
window.executeClose = executeClose;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOTSTRAP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function init() {
  // Load config from server (API keys)
  await loadServerConfig();
  
  // Initialize default ticker metadata
  const defaultMeta = {
    NVDA: { name: 'NVIDIA', color: '#76B900', sma50: 192, sma200: 155, support: 170, resistance: 192, ath: 212.19, earningsDate: '2026-02-25', earningsImportance: 95, analystTarget: 253.62, analystBuy: 59, analystSell: 1, forwardPe: 28, pegRatio: 0.82, ivPctile: 70, sentiment: 65, beta: 1.8, notes: 'Core AI play. Earnings Feb 25.' },
    AMD: { name: 'AMD', color: '#ED1C24', sma50: 225, sma200: 175, support: 180, resistance: 205, ath: 267.08, earningsDate: '2026-05-05', earningsImportance: 60, analystTarget: 210, analystBuy: 35, analystSell: 3, forwardPe: 32, pegRatio: 1.1, ivPctile: 80, sentiment: 35, beta: 1.9, notes: 'Weak Q1 guide.' },
    MU: { name: 'Micron', color: '#005FAD', sma50: 370, sma200: 280, support: 360, resistance: 410, ath: 410.78, earningsDate: '2026-04-01', earningsImportance: 75, analystTarget: 450, analystBuy: 28, analystSell: 2, forwardPe: 12, pegRatio: 0.3, ivPctile: 60, sentiment: 40, beta: 1.5, notes: 'Low PEG. HBM play.' },
    MSFT: { name: 'Microsoft', color: '#00A4EF', sma50: 430, sma200: 440, support: 390, resistance: 430, ath: 555.45, earningsDate: '2026-04-28', earningsImportance: 65, analystTarget: 599.86, analystBuy: 40, analystSell: 1, forwardPe: 28, pegRatio: 1.8, ivPctile: 45, sentiment: 50, beta: 1.0, notes: 'Azure growth. Defensive AI.' },
    NFLX: { name: 'Netflix', color: '#E50914', sma50: 88, sma200: 78, support: 78, resistance: 90, ath: 105, earningsDate: '2026-04-15', earningsImportance: 55, analystTarget: 95, analystBuy: 25, analystSell: 5, forwardPe: 35, pegRatio: 1.5, ivPctile: 40, sentiment: 55, beta: 1.3, notes: 'Watchlist only.' }
  };
  
  for (const [ticker, meta] of Object.entries(defaultMeta)) {
    S.tickerData[ticker] = { ...meta, _live: {} };
  }
  
  // Build initial UI
  buildStructure();
  
  // Connect WebSocket
  if (S.apiKey) {
    connectWS();
  }
  
  // Initial data fetch
  pollFinnhub();
  fetchFearGreed();
  fetchHistoricalRSI().then(() => {
    // After DB data loads, overlay with Alpha Vantage real indicators (more accurate)
    fetchAlphaVantageIndicators();
  });
  fetchOptionsData();
  fetchNewsSentiment();
  
  // Polling intervals
  setInterval(pollFinnhub, POLL_MS);
  setInterval(fetchFearGreed, 300000);
  setInterval(fetchHistoricalRSI, 600000);
  setInterval(fetchOptionsData, 900000);
  setInterval(fetchNewsSentiment, 1800000); // News every 30 min
  
  // Countdown timer
  setInterval(() => {
    S.countdown = Math.max(0, S.countdown - 1);
    setText('countdown', S.countdown);
  }, 1000);
}

init();
</script>
</body>
</html>
